{"version":3,"file":"use-merged-state-6be15dc6.js","sources":["../../../node_modules/naive-ui/es/_utils/vue/call.js","../../../node_modules/naive-ui/es/_utils/vue/resolve-slot.js","../../../node_modules/vooks/es/use-merged-state.js"],"sourcesContent":["function call(funcs, ...args) {\n    if (Array.isArray(funcs)) {\n        funcs.forEach((func) => call(func, ...args));\n    }\n    else\n        return funcs(...args);\n}\nexport { call };\n","import { Fragment, isVNode, Comment } from 'vue';\nfunction ensureValidVNode(vnodes) {\n    return vnodes.some((child) => {\n        if (!isVNode(child)) {\n            return true;\n        }\n        if (child.type === Comment) {\n            return false;\n        }\n        if (child.type === Fragment &&\n            !ensureValidVNode(child.children)) {\n            return false;\n        }\n        return true;\n    })\n        ? vnodes\n        : null;\n}\n/**\n * We shouldn't use the following functions with slot flags `_: 1, 2, 3`\n */\nexport function resolveSlot(slot, fallback) {\n    return (slot && ensureValidVNode(slot())) || fallback();\n}\nexport function resolveSlotWithProps(slot, props, fallback) {\n    return (slot && ensureValidVNode(slot(props))) || fallback(props);\n}\n/**\n * Resolve slot with wrapper if content exists, no fallback\n */\nexport function resolveWrappedSlot(slot, wrapper) {\n    const children = slot && ensureValidVNode(slot());\n    return wrapper(children || null);\n}\n/*\n * Resolve slot with wrapper if content exists, no fallback\n */\nexport function resolveWrappedSlotWithProps(slot, props, wrapper) {\n    const children = slot && ensureValidVNode(slot(props));\n    return wrapper(children || null);\n}\nexport function isSlotEmpty(slot) {\n    return !(slot && ensureValidVNode(slot()));\n}\n","import { watch, computed } from 'vue';\nexport default function useMergedState(controlledStateRef, uncontrolledStateRef) {\n    watch(controlledStateRef, value => {\n        if (value !== undefined) {\n            uncontrolledStateRef.value = value;\n        }\n    });\n    return computed(() => {\n        if (controlledStateRef.value === undefined) {\n            return uncontrolledStateRef.value;\n        }\n        return controlledStateRef.value;\n    });\n}\n"],"names":["call","funcs","args","Array","isArray","forEach","func","ensureValidVNode","vnodes","some","child","isVNode","type","Comment","Fragment","children","resolveSlot","slot","fallback","resolveSlotWithProps","props","resolveWrappedSlot","wrapper","resolveWrappedSlotWithProps","isSlotEmpty","useMergedState","controlledStateRef","uncontrolledStateRef","watch","value","computed"],"mappings":"qEAAA,SAASA,EAAKC,KAAUC,GAChB,IAAAC,MAAMC,QAAQH,GAIP,OAAAA,KAASC,GAHhBD,EAAMI,SAASC,GAASN,EAAKM,KAASJ,IAI9C,CCLA,SAASK,EAAiBC,GACf,OAAAA,EAAOC,MAAMC,IACXC,EAAQD,IAGTA,EAAME,OAASC,KAGfH,EAAME,OAASE,IACdP,EAAiBG,EAAMK,aAK1BP,EACA,IACV,CAIO,SAASQ,EAAYC,EAAMC,GAC9B,OAAQD,GAAQV,EAAiBU,MAAYC,GACjD,CACO,SAASC,EAAqBF,EAAMG,EAAOF,GAC9C,OAAQD,GAAQV,EAAiBU,EAAKG,KAAYF,EAASE,EAC/D,CAIO,SAASC,EAAmBJ,EAAMK,GAE9B,OAAAA,EADUL,GAAQV,EAAiBU,MACf,KAC/B,CAIO,SAASM,EAA4BN,EAAMG,EAAOE,GAE9C,OAAAA,EADUL,GAAQV,EAAiBU,EAAKG,KACpB,KAC/B,CACO,SAASI,EAAYP,GACxB,QAASA,GAAQV,EAAiBU,KACtC,CC1Ce,SAASQ,EAAeC,EAAoBC,GAMvD,OALAC,EAAMF,GAA6BG,SACjB,IAAVA,IACAF,EAAqBE,MAAQA,EAChC,IAEEC,GAAS,SACqB,IAA7BJ,EAAmBG,MACZF,EAAqBE,MAEzBH,EAAmBG,OAElC","x_google_ignoreList":[0,1,2]}