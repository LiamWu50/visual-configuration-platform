{"version":3,"file":"create-e88f5dcb.js","sources":["../../../node_modules/seemly/es/dom/happens-in.js","../../../node_modules/treemate/es/utils.js","../../../node_modules/treemate/es/check.js","../../../node_modules/treemate/es/move.js","../../../node_modules/treemate/es/flatten.js","../../../node_modules/treemate/es/create.js","../../../node_modules/treemate/es/contains.js","../../../node_modules/treemate/es/path.js"],"sourcesContent":["export function happensIn(e, dataSetPropName) {\n    let { target } = e;\n    while (target) {\n        if (target.dataset) {\n            if (target.dataset[dataSetPropName] !== undefined)\n                return true;\n        }\n        target = target.parentElement;\n    }\n    return false;\n}\n","export function toArray(arg) {\n    if (Array.isArray(arg))\n        return arg;\n    return [arg];\n}\n// Do not use enum for lint plugin has error\nexport const TRAVERSE_COMMAND = {\n    STOP: 'STOP'\n};\nexport function traverseWithCb(treeNode, callback) {\n    const command = callback(treeNode);\n    if (treeNode.children !== undefined && command !== TRAVERSE_COMMAND.STOP) {\n        treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));\n    }\n}\nexport function getNonLeafKeys(treeNodes, options = {}) {\n    const { preserveGroup = false } = options;\n    const keys = [];\n    const cb = preserveGroup\n        ? (node) => {\n            if (!node.isLeaf) {\n                keys.push(node.key);\n                traverse(node.children);\n            }\n        }\n        : (node) => {\n            if (!node.isLeaf) {\n                if (!node.isGroup)\n                    keys.push(node.key);\n                traverse(node.children);\n            }\n        };\n    function traverse(nodes) {\n        nodes.forEach(cb);\n    }\n    traverse(treeNodes);\n    return keys;\n}\nexport function isLeaf(rawNode, getChildren) {\n    const { isLeaf } = rawNode;\n    if (isLeaf !== undefined)\n        return isLeaf;\n    else if (!getChildren(rawNode))\n        return true;\n    return false;\n}\nexport function defaultGetChildren(node) {\n    return node.children;\n}\nexport function defaultGetKey(node) {\n    return node.key;\n}\nexport function isIgnored() {\n    return false;\n}\nexport function isShallowLoaded(rawNode, getChildren) {\n    const { isLeaf } = rawNode;\n    if (isLeaf === false && !Array.isArray(getChildren(rawNode)))\n        return false;\n    return true;\n}\nexport function isDisabled(rawNode) {\n    return rawNode.disabled === true;\n}\nexport function isExpilicitlyNotLoaded(rawNode, getChildren) {\n    return (rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode)));\n}\nexport function isNodeInvalid(rawNode, getChildren) {\n    if (rawNode.isLeaf === true) {\n        const children = getChildren(rawNode);\n        if (Array.isArray(children) && children.length > 0)\n            return true;\n    }\n    return false;\n}\nexport function unwrapCheckedKeys(result) {\n    var _a;\n    if (result === undefined || result === null)\n        return [];\n    if (Array.isArray(result))\n        return result;\n    return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];\n}\nexport function unwrapIndeterminateKeys(result) {\n    var _a;\n    if (result === undefined || result === null || Array.isArray(result)) {\n        return [];\n    }\n    return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];\n}\nexport function merge(originalKeys, keysToAdd) {\n    const set = new Set(originalKeys);\n    keysToAdd.forEach((key) => {\n        if (!set.has(key)) {\n            set.add(key);\n        }\n    });\n    return Array.from(set);\n}\nexport function minus(originalKeys, keysToRemove) {\n    const set = new Set(originalKeys);\n    keysToRemove.forEach((key) => {\n        if (set.has(key)) {\n            set.delete(key);\n        }\n    });\n    return Array.from(set);\n}\nexport function isGroup(rawNode) {\n    return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === 'group';\n}\nexport function createIndexGetter(treeNodes) {\n    const map = new Map();\n    treeNodes.forEach((treeNode, i) => {\n        map.set(treeNode.key, i);\n    });\n    return (key) => { var _a; return (_a = map.get(key)) !== null && _a !== void 0 ? _a : null; };\n}\n","import { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n    constructor() {\n        super();\n        this.message =\n            'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n    }\n}\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n    const visitedKeys = new Set();\n    uncheckedKeys.forEach((uncheckedKey) => {\n        const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n        if (uncheckedTreeNode !== undefined) {\n            let nodeCursor = uncheckedTreeNode.parent;\n            while (nodeCursor !== null) {\n                if (nodeCursor.disabled)\n                    break;\n                if (visitedKeys.has(nodeCursor.key))\n                    break;\n                else {\n                    visitedKeys.add(nodeCursor.key);\n                }\n                nodeCursor = nodeCursor.parent;\n            }\n        }\n    });\n    return visitedKeys;\n}\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n    const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n    const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n    const keysToRemove = [];\n    extendedCheckedKeySet.forEach((key) => {\n        if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n            keysToRemove.push(key);\n        }\n    });\n    keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));\n    return extendedCheckedKeySet;\n}\nexport function getCheckedKeys(options, treeMate) {\n    const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;\n    if (!cascade) {\n        if (keysToCheck !== undefined) {\n            return {\n                checkedKeys: merge(checkedKeys, keysToCheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else if (keysToUncheck !== undefined) {\n            return {\n                checkedKeys: minus(checkedKeys, keysToUncheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else {\n            return {\n                checkedKeys: Array.from(checkedKeys),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n    }\n    const { levelTreeNodeMap } = treeMate;\n    let extendedCheckedKeySet;\n    if (keysToUncheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else if (keysToCheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else {\n        extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n    }\n    const checkStrategyIsParent = checkStrategy === 'parent';\n    const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n    const syntheticCheckedKeySet = extendedCheckedKeySet;\n    const syntheticIndeterminateKeySet = new Set();\n    const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));\n    // cascade check\n    // 1. if tree is fully loaded, it just works\n    // 2. if the tree is not fully loaded, we assume that keys which is in not\n    //    loaded tree are not in checked keys\n    //    for example:\n    //    a -- b(fully-loaded)   -- c(fully-loaded)\n    //      |- d(partial-loaded) -- ?e(not-loaded)\n    //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n    //    and `a`'s status\n    for (let level = maxLevel; level >= 0; level -= 1) {\n        const levelIsZero = level === 0;\n        // it should exists, nor it is a bug\n        const levelTreeNodes = levelTreeNodeMap.get(level);\n        for (const levelTreeNode of levelTreeNodes) {\n            if (levelTreeNode.isLeaf)\n                continue;\n            const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;\n            if (checkStrategyIsChild && shallowLoaded) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                levelTreeNode.children.forEach((v) => {\n                    if (!v.disabled &&\n                        !v.isLeaf &&\n                        v.shallowLoaded &&\n                        syntheticCheckedKeySet.has(v.key)) {\n                        syntheticCheckedKeySet.delete(v.key);\n                    }\n                });\n            }\n            if (levelTreeNode.disabled || !shallowLoaded) {\n                continue;\n            }\n            let fullyChecked = true;\n            let partialChecked = false;\n            let allDisabled = true;\n            // it is shallow loaded, so `children` must exist\n            for (const childNode of levelTreeNode.children) {\n                const childKey = childNode.key;\n                if (childNode.disabled)\n                    continue;\n                if (allDisabled)\n                    allDisabled = false;\n                if (syntheticCheckedKeySet.has(childKey)) {\n                    partialChecked = true;\n                }\n                else if (syntheticIndeterminateKeySet.has(childKey)) {\n                    partialChecked = true;\n                    fullyChecked = false;\n                    break;\n                }\n                else {\n                    fullyChecked = false;\n                    if (partialChecked) {\n                        break;\n                    }\n                }\n            }\n            if (fullyChecked && !allDisabled) {\n                if (checkStrategyIsParent) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    levelTreeNode.children.forEach((v) => {\n                        if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n                            syntheticCheckedKeySet.delete(v.key);\n                        }\n                    });\n                }\n                syntheticCheckedKeySet.add(levelTreeNodeKey);\n            }\n            else if (partialChecked) {\n                syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n            }\n            if (levelIsZero &&\n                checkStrategyIsChild &&\n                syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n                syntheticCheckedKeySet.delete(levelTreeNodeKey);\n            }\n        }\n    }\n    return {\n        checkedKeys: Array.from(syntheticCheckedKeySet),\n        indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n    };\n}\n// unchecking is safe when doing cascade uncheck in async mode\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n    const { treeNodeMap, getChildren } = treeMate;\n    const visitedKeySet = new Set();\n    const extendedKeySet = new Set(checkedKeys);\n    checkedKeys.forEach((checkedKey) => {\n        const checkedTreeNode = treeNodeMap.get(checkedKey);\n        if (checkedTreeNode !== undefined) {\n            traverseWithCb(checkedTreeNode, (treeNode) => {\n                if (treeNode.disabled) {\n                    return TRAVERSE_COMMAND.STOP;\n                }\n                const { key } = treeNode;\n                if (visitedKeySet.has(key))\n                    return;\n                visitedKeySet.add(key);\n                // Adding keys before loaded check is okay, since if not valid error\n                // would be thrown\n                extendedKeySet.add(key);\n                if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n                    if (isUnchecking) {\n                        return TRAVERSE_COMMAND.STOP;\n                    }\n                    else if (!allowNotLoaded) {\n                        throw new SubtreeNotLoadedError();\n                    }\n                }\n            });\n        }\n    });\n    return extendedKeySet;\n}\n","export function getFirstAvailableNode(nodes) {\n    if (nodes.length === 0)\n        return null;\n    const node = nodes[0];\n    if (node.isGroup || node.ignored || node.disabled) {\n        return node.getNext();\n    }\n    return node;\n}\nfunction rawGetNext(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index + 1) % l];\n    }\n    else {\n        if (index === sibs.length - 1)\n            return null;\n        return sibs[index + 1];\n    }\n}\nfunction move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {\n    const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;\n    const getChildOptions = {\n        reverse: dir === 'prev'\n    };\n    let meet = false;\n    let endNode = null;\n    function traverse(node) {\n        if (node === null)\n            return;\n        if (node === fromNode) {\n            if (!meet) {\n                meet = true;\n            }\n            else if (!fromNode.disabled && !fromNode.isGroup) {\n                endNode = fromNode;\n                return;\n            }\n        }\n        else {\n            if ((!node.disabled || includeDisabled) &&\n                !node.ignored &&\n                !node.isGroup) {\n                endNode = node;\n                return;\n            }\n        }\n        if (node.isGroup) {\n            const child = getChild(node, getChildOptions);\n            if (child !== null) {\n                endNode = child;\n            }\n            else {\n                traverse(iterate(node, loop));\n            }\n        }\n        else {\n            const nextNode = iterate(node, false);\n            if (nextNode !== null) {\n                traverse(nextNode);\n            }\n            else {\n                const parent = rawGetParent(node);\n                if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n                    traverse(iterate(parent, loop));\n                }\n                else if (loop) {\n                    traverse(iterate(node, true));\n                }\n            }\n        }\n    }\n    traverse(fromNode);\n    return endNode;\n}\nfunction rawGetPrev(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index - 1 + l) % l];\n    }\n    else {\n        if (index === 0)\n            return null;\n        return sibs[index - 1];\n    }\n}\nfunction rawGetParent(node) {\n    return node.parent;\n}\nfunction getChild(node, options = {}) {\n    const { reverse = false } = options;\n    const { children } = node;\n    if (children) {\n        const { length } = children;\n        const start = reverse ? length - 1 : 0;\n        const end = reverse ? -1 : length;\n        const delta = reverse ? -1 : 1;\n        for (let i = start; i !== end; i += delta) {\n            const child = children[i];\n            if (!child.disabled && !child.ignored) {\n                if (child.isGroup) {\n                    const childInGroup = getChild(child, options);\n                    if (childInGroup !== null)\n                        return childInGroup;\n                }\n                else {\n                    return child;\n                }\n            }\n        }\n    }\n    return null;\n}\nexport const moveMethods = {\n    getChild() {\n        if (this.ignored)\n            return null;\n        return getChild(this);\n    },\n    getParent() {\n        const { parent } = this;\n        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n            return parent.getParent();\n        }\n        return parent;\n    },\n    getNext(options = {}) {\n        return move(this, 'next', options);\n    },\n    getPrev(options = {}) {\n        return move(this, 'prev', options);\n    }\n};\n","export function flatten(treeNodes, expandedKeys) {\n    const expandedKeySet = expandedKeys ? new Set(expandedKeys) : undefined;\n    const flattenedNodes = [];\n    function traverse(treeNodes) {\n        treeNodes.forEach((treeNode) => {\n            flattenedNodes.push(treeNode);\n            if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)\n                return;\n            if (treeNode.isGroup) {\n                // group node shouldn't be expanded\n                traverse(treeNode.children);\n            }\n            else if (\n            // normal non-leaf node\n            expandedKeySet === undefined ||\n                expandedKeySet.has(treeNode.key)) {\n                traverse(treeNode.children);\n            }\n        });\n    }\n    traverse(treeNodes);\n    return flattenedNodes;\n}\n","import { getCheckedKeys } from './check';\nimport { toArray, isDisabled, isLeaf, isGroup, isNodeInvalid, unwrapCheckedKeys, isShallowLoaded, unwrapIndeterminateKeys, getNonLeafKeys, isIgnored, defaultGetChildren, defaultGetKey } from './utils';\nimport { getPath } from './path';\nimport { moveMethods, getFirstAvailableNode } from './move';\nimport { flatten } from './flatten';\nimport { contains } from './contains';\nfunction createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {\n    const treeNodes = [];\n    rawNodes.forEach((rawNode, index) => {\n        var _a;\n        if (process.env.NODE_ENV !== 'production' &&\n            isNodeInvalid(rawNode, getChildren)) {\n            console.error('[treemate]: node', rawNode, 'is invalid');\n        }\n        const treeNode = Object.create(nodeProto);\n        treeNode.rawNode = rawNode;\n        treeNode.siblings = treeNodes;\n        treeNode.level = level;\n        treeNode.index = index;\n        treeNode.isFirstChild = index === 0;\n        treeNode.isLastChild = index + 1 === rawNodes.length;\n        treeNode.parent = parent;\n        if (!treeNode.ignored) {\n            const rawChildren = getChildren(rawNode);\n            if (Array.isArray(rawChildren)) {\n                treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);\n            }\n        }\n        treeNodes.push(treeNode);\n        treeNodeMap.set(treeNode.key, treeNode);\n        if (!levelTreeNodeMap.has(level))\n            levelTreeNodeMap.set(level, []);\n        (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);\n    });\n    return treeNodes;\n}\nexport function createTreeMate(rawNodes, options = {}) {\n    var _a;\n    const treeNodeMap = new Map();\n    const levelTreeNodeMap = new Map();\n    const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;\n    const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;\n    const getChildren = options.ignoreEmptyChildren\n        ? (node) => {\n            const children = _getChildren(node);\n            if (Array.isArray(children)) {\n                if (!children.length)\n                    return null;\n                return children;\n            }\n            return children;\n        }\n        : _getChildren;\n    const nodeProto = Object.assign({\n        get key() {\n            // do not pass parent or related things to it\n            // the key need to be specified explicitly\n            return getKey(this.rawNode);\n        },\n        get disabled() {\n            return getDisabled(this.rawNode);\n        },\n        get isGroup() {\n            return getIsGroup(this.rawNode);\n        },\n        get isLeaf() {\n            return isLeaf(this.rawNode, getChildren);\n        },\n        get shallowLoaded() {\n            return isShallowLoaded(this.rawNode, getChildren);\n        },\n        get ignored() {\n            return getIgnored(this.rawNode);\n        },\n        contains(node) {\n            return contains(this, node);\n        }\n    }, moveMethods);\n    const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);\n    function getNode(key) {\n        if (key === null || key === undefined)\n            return null;\n        const tmNode = treeNodeMap.get(key);\n        if (tmNode && !tmNode.isGroup && !tmNode.ignored) {\n            return tmNode;\n        }\n        return null;\n    }\n    function _getNode(key) {\n        if (key === null || key === undefined)\n            return null;\n        const tmNode = treeNodeMap.get(key);\n        if (tmNode && !tmNode.ignored) {\n            return tmNode;\n        }\n        return null;\n    }\n    function getPrev(key, options) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getPrev(options);\n    }\n    function getNext(key, options) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getNext(options);\n    }\n    function getParent(key) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getParent();\n    }\n    function getChild(key) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getChild();\n    }\n    const treemate = {\n        treeNodes,\n        treeNodeMap,\n        levelTreeNodeMap,\n        maxLevel: Math.max(...levelTreeNodeMap.keys()),\n        getChildren,\n        getFlattenedNodes(expandedKeys) {\n            return flatten(treeNodes, expandedKeys);\n        },\n        getNode,\n        getPrev,\n        getNext,\n        getParent,\n        getChild,\n        getFirstAvailableNode() {\n            return getFirstAvailableNode(treeNodes);\n        },\n        getPath(key, options = {}) {\n            return getPath(key, options, treemate);\n        },\n        getCheckedKeys(checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        check(keysToCheck, checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                keysToCheck: keysToCheck === undefined || keysToCheck === null\n                    ? []\n                    : toArray(keysToCheck),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        uncheck(keysToUncheck, checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                keysToUncheck: keysToUncheck === null || keysToUncheck === undefined\n                    ? []\n                    : toArray(keysToUncheck),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        getNonLeafKeys(options = {}) {\n            return getNonLeafKeys(treeNodes, options);\n        }\n    };\n    return treemate;\n}\n","export function contains(parent, child) {\n    const parentKey = parent.key;\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (child) {\n        if (child.key === parentKey)\n            return true;\n        child = child.parent;\n    }\n    return false;\n}\n","export function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {\n    var _a;\n    const treeNodeMap = treeMate.treeNodeMap;\n    let treeNode = key === null || key === undefined ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;\n    const mergedPath = {\n        keyPath: [],\n        treeNodePath: [],\n        treeNode: treeNode\n    };\n    if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {\n        mergedPath.treeNode = null;\n        return mergedPath;\n    }\n    while (treeNode) {\n        if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {\n            mergedPath.treeNodePath.push(treeNode);\n        }\n        treeNode = treeNode.parent;\n    }\n    mergedPath.treeNodePath.reverse();\n    if (!includeSelf)\n        mergedPath.treeNodePath.pop();\n    mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode) => treeNode.key);\n    return mergedPath;\n}\n"],"names":["happensIn","e","dataSetPropName","target","dataset","parentElement","toArray","arg","Array","isArray","TRAVERSE_COMMAND","STOP","traverseWithCb","treeNode","callback","command","children","forEach","childNode","defaultGetChildren","node","defaultGetKey","key","isIgnored","isDisabled","rawNode","disabled","unwrapCheckedKeys","result","_a","checkedKeys","unwrapIndeterminateKeys","indeterminateKeys","merge","originalKeys","keysToAdd","set","Set","has","add","from","minus","keysToRemove","delete","isGroup","type","createIndexGetter","treeNodes","map","Map","i","get","SubtreeNotLoadedError","Error","constructor","this","message","getExtendedCheckedKeySetAfterUncheck","uncheckedKeys","currentCheckedKeys","treeMate","allowNotLoaded","extendedCheckedKeySet","getExtendedCheckedKeySet","extendedKeySetToUncheck","ascendantKeySet","visitedKeys","uncheckedKey","uncheckedTreeNode","treeNodeMap","nodeCursor","parent","getAvailableAscendantNodeSet","push","getCheckedKeys","options","keysToCheck","keysToUncheck","cascade","leafOnly","checkStrategy","levelTreeNodeMap","checkKeys","concat","getExtendedCheckedKeySetAfterCheck","checkStrategyIsParent","checkStrategyIsChild","syntheticCheckedKeySet","syntheticIndeterminateKeySet","level","Math","max","apply","keys","levelIsZero","levelTreeNodes","levelTreeNode","isLeaf","levelTreeNodeKey","shallowLoaded","v","fullyChecked","partialChecked","allDisabled","childKey","isUnchecking","getChildren","visitedKeySet","extendedKeySet","checkedKey","checkedTreeNode","isExpilicitlyNotLoaded","rawGetNext","loop","sibs","siblings","l","length","index","move","fromNode","dir","includeDisabled","iterate","rawGetPrev","getChildOptions","reverse","meet","endNode","traverse","ignored","child","getChild","nextNode","rawGetParent","end","delta","childInGroup","moveMethods","getParent","getNext","getPrev","flatten","expandedKeys","expandedKeySet","flattenedNodes","createTreeNodes","rawNodes","nodeProto","isNodeInvalid","Object","create","isFirstChild","isLastChild","rawChildren","createTreeMate","getDisabled","getIgnored","getIsGroup","getKey","_getChildren","ignoreEmptyChildren","assign","isShallowLoaded","contains","parentKey","_getNode","tmNode","treemate","maxLevel","getFlattenedNodes","getNode","getFirstAvailableNode","nodes","getPath","includeGroup","includeSelf","mergedPath","keyPath","treeNodePath","pop","check","uncheck","getNonLeafKeys","preserveGroup","cb"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}