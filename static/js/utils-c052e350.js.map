{"version":3,"file":"utils-c052e350.js","sources":["../../../node_modules/naive-ui/es/_utils/env/is-native-lazy-load.js","../../../node_modules/naive-ui/es/image/src/utils.js"],"sourcesContent":["import { isBrowser } from './is-browser';\nexport const isImageSupportNativeLazy = isBrowser && 'loading' in document.createElement('img');\n","export const resolveOptionsAndHash = (options = {}) => {\n    var _a;\n    const { root = null } = options;\n    return {\n        hash: `${options.rootMargin || '0px 0px 0px 0px'}-${Array.isArray(options.threshold)\n            ? options.threshold.join(',')\n            : (_a = options.threshold) !== null && _a !== void 0 ? _a : '0'}`,\n        options: Object.assign(Object.assign({}, options), { root: (typeof root === 'string' ? document.querySelector(root) : root) ||\n                document.documentElement })\n    };\n};\n// root -> options -> [observer, elements]\nconst observers = new WeakMap();\nconst unobserveHandleMap = new WeakMap();\nconst shouldStartLoadingRefMap = new WeakMap();\nexport const observeIntersection = (el, options, shouldStartLoadingRef) => {\n    if (!el)\n        return () => { };\n    const resolvedOptionsAndHash = resolveOptionsAndHash(options);\n    const { root } = resolvedOptionsAndHash.options;\n    let rootObservers;\n    const _rootObservers = observers.get(root);\n    if (_rootObservers) {\n        rootObservers = _rootObservers;\n    }\n    else {\n        rootObservers = new Map();\n        observers.set(root, rootObservers);\n    }\n    let observer;\n    let observerAndObservedElements;\n    if (rootObservers.has(resolvedOptionsAndHash.hash)) {\n        observerAndObservedElements =\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            rootObservers.get(resolvedOptionsAndHash.hash);\n        if (!observerAndObservedElements[1].has(el)) {\n            observer = observerAndObservedElements[0];\n            observerAndObservedElements[1].add(el);\n            observer.observe(el);\n        }\n    }\n    else {\n        observer = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    const _unobserve = unobserveHandleMap.get(entry.target);\n                    const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);\n                    if (_unobserve)\n                        _unobserve();\n                    if (_shouldStartLoadingRef) {\n                        _shouldStartLoadingRef.value = true;\n                    }\n                }\n            });\n        }, resolvedOptionsAndHash.options);\n        observer.observe(el);\n        observerAndObservedElements = [observer, new Set([el])];\n        rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);\n    }\n    let unobservered = false;\n    const unobserve = () => {\n        if (unobservered)\n            return;\n        unobserveHandleMap.delete(el);\n        shouldStartLoadingRefMap.delete(el);\n        unobservered = true;\n        if (observerAndObservedElements[1].has(el)) {\n            observerAndObservedElements[0].unobserve(el);\n            observerAndObservedElements[1].delete(el);\n        }\n        if (observerAndObservedElements[1].size <= 0) {\n            rootObservers.delete(resolvedOptionsAndHash.hash);\n        }\n        if (!rootObservers.size) {\n            observers.delete(root);\n        }\n    };\n    unobserveHandleMap.set(el, unobserve);\n    shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);\n    return unobserve;\n};\n"],"names":["isImageSupportNativeLazy","isBrowser","document","createElement","observers","WeakMap","unobserveHandleMap","shouldStartLoadingRefMap","observeIntersection","el","options","shouldStartLoadingRef","resolvedOptionsAndHash","_a","root","hash","rootMargin","Array","isArray","threshold","join","Object","assign","querySelector","documentElement","resolveOptionsAndHash","rootObservers","_rootObservers","get","observer","observerAndObservedElements","Map","set","has","add","observe","IntersectionObserver","entries","forEach","entry","isIntersecting","_unobserve","target","_shouldStartLoadingRef","value","Set","unobservered","unobserve","delete","size"],"mappings":"6CACY,MAACA,EAA2BC,GAAa,YAAaC,SAASC,cAAc,OCWnFC,MAAgBC,QAChBC,MAAyBD,QACzBE,MAA+BF,QACxBG,EAAsB,CAACC,EAAIC,EAASC,KAC7C,IAAKF,EACD,MAAO,OACL,MAAAG,EAlB2B,EAACF,EAAU,MACxC,IAAAG,EACE,MAAAC,KAAEA,EAAO,MAASJ,EACjB,MAAA,CACHK,KAAM,GAAGL,EAAQM,YAAc,qBAAqBC,MAAMC,QAAQR,EAAQS,WACpET,EAAQS,UAAUC,KAAK,KACM,QAA5BP,EAAKH,EAAQS,iBAA8B,IAAPN,EAAgBA,EAAK,MAChEH,QAASW,OAAOC,OAAOD,OAAOC,OAAO,CAAE,EAAEZ,GAAU,CAAEI,MAAuB,iBAATA,EAAoBZ,SAASqB,cAAcT,GAAQA,IAC9GZ,SAASsB,kBACzB,EASmCC,CAAsBf,IAC/CI,KAAEA,GAASF,EAAuBF,QACpC,IAAAgB,EACE,MAAAC,EAAiBvB,EAAUwB,IAAId,GAQjC,IAAAe,EACAC,EARAH,EACgBD,EAAAC,GAGhBD,MAAoBK,IACV3B,EAAA4B,IAAIlB,EAAMY,IAIpBA,EAAcO,IAAIrB,EAAuBG,OACzCe,EAEIJ,EAAcE,IAAIhB,EAAuBG,MACxCe,EAA4B,GAAGG,IAAIxB,KACpCoB,EAAWC,EAA4B,GACXA,EAAA,GAAGI,IAAIzB,GACnCoB,EAASM,QAAQ1B,MAIVoB,EAAA,IAAIO,sBAAsBC,IACzBA,EAAAC,SAASC,IACb,GAAIA,EAAMC,eAAgB,CACtB,MAAMC,EAAanC,EAAmBsB,IAAIW,EAAMG,QAC1CC,EAAyBpC,EAAyBqB,IAAIW,EAAMG,QAC9DD,OAEAE,IACAA,EAAuBC,OAAQ,EAEtC,IACJ,GACFhC,EAAuBF,SAC1BmB,EAASM,QAAQ1B,GACjBqB,EAA8B,CAACD,EAAU,IAAIgB,IAAI,CAACpC,KACpCiB,EAAAM,IAAIpB,EAAuBG,KAAMe,IAEnD,IAAIgB,GAAe,EACnB,MAAMC,EAAY,KACVD,IAEJxC,EAAmB0C,OAAOvC,GAC1BF,EAAyByC,OAAOvC,GACjBqC,GAAA,EACXhB,EAA4B,GAAGG,IAAIxB,KACPqB,EAAA,GAAGiB,UAAUtC,GACbqB,EAAA,GAAGkB,OAAOvC,IAEtCqB,EAA4B,GAAGmB,MAAQ,GACzBvB,EAAAsB,OAAOpC,EAAuBG,MAE3CW,EAAcuB,MACf7C,EAAU4C,OAAOlC,GACpB,EAIE,OAFYR,EAAA0B,IAAIvB,EAAIsC,GACFxC,EAAAyB,IAAIvB,EAAIE,GAC1BoC,CAAA","x_google_ignoreList":[0,1]}