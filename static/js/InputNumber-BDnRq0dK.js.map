{"version":3,"file":"InputNumber-BDnRq0dK.js","sources":["../../../node_modules/naive-ui/es/_utils/composable/use-collection.mjs","../../../node_modules/naive-ui/es/_internal/icons/Remove.mjs","../../../node_modules/naive-ui/es/form/src/context.mjs","../../../node_modules/async-validator/dist-web/index.js","../../../node_modules/naive-ui/es/_styles/transitions/fade-down.cssr.mjs","../../../node_modules/naive-ui/es/form/src/styles/form-item.cssr.mjs","../../../node_modules/naive-ui/es/form/src/FormItem.mjs","../../../node_modules/naive-ui/es/form/src/utils.mjs","../../../node_modules/naive-ui/es/input-number/styles/light.mjs","../../../node_modules/naive-ui/es/input-number/src/utils.mjs","../../../node_modules/naive-ui/es/input-number/src/styles/input-number.cssr.mjs","../../../node_modules/naive-ui/es/input-number/src/InputNumber.mjs"],"sourcesContent":["import { watch, onMounted, inject, getCurrentInstance, onBeforeUnmount } from 'vue';\n// injection.collection {\n//   key1: [insta, instb]\n//   key2: [instc]\n// }\nexport function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {\n  var _a;\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n  const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;\n  watch(registerKeyRef, registerInstance);\n  registerInstance(registerKeyRef.value);\n  onBeforeUnmount(() => {\n    registerInstance(undefined, registerKeyRef.value);\n  });\n  function registerInstance(key, oldKey) {\n    if (!injection) return;\n    const collection = injection[collectionKey];\n    if (oldKey !== undefined) removeInstance(collection, oldKey);\n    if (key !== undefined) addInstance(collection, key);\n  }\n  function removeInstance(collection, key) {\n    if (!collection[key]) collection[key] = [];\n    collection[key].splice(collection[key].findIndex(instance => instance === vm), 1);\n  }\n  function addInstance(collection, key) {\n    if (!collection[key]) collection[key] = [];\n    if (!~collection[key].findIndex(instance => instance === vm)) {\n      collection[key].push(vm);\n    }\n  }\n}\n// injection.collection {\n//   key1: [insta.value, instb.value]\n//   key2: [instc.value]\n// }\nexport function useInjectionCollection(injectionName, collectionKey, valueRef) {\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n  if (!(collectionKey in injection)) {\n    injection[collectionKey] = [];\n  }\n  injection[collectionKey].push(valueRef.value);\n  watch(valueRef, (value, prevValue) => {\n    const collectionArray = injection[collectionKey];\n    const index = collectionArray.findIndex(collectionValue => collectionValue === prevValue);\n    if (~index) collectionArray.splice(index, 1);\n    collectionArray.push(value);\n  });\n  onBeforeUnmount(() => {\n    const collectionArray = injection[collectionKey];\n    const index = collectionArray.findIndex(collectionValue => collectionValue === valueRef.value);\n    if (~index) collectionArray.splice(index, 1);\n  });\n}\n// injection.collection {\n//   key1: [insta.$el, instb.$el]\n//   key2: [instc.$el]\n// }\nexport function useInjectionElementCollection(injectionName, collectionKey, getElement) {\n  const injection = inject(injectionName, null);\n  if (injection === null) return;\n  if (!(collectionKey in injection)) {\n    injection[collectionKey] = [];\n  }\n  onMounted(() => {\n    const el = getElement();\n    if (!el) return;\n    injection[collectionKey].push(el);\n  });\n  onBeforeUnmount(() => {\n    const collectionArray = injection[collectionKey];\n    const element = getElement();\n    const index = collectionArray.findIndex(collectionElement => collectionElement === element);\n    if (~index) collectionArray.splice(index, 1);\n  });\n}","import { h, defineComponent } from 'vue';\nexport default defineComponent({\n  name: 'Remove',\n  render() {\n    return h(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 512 512\"\n    }, h(\"line\", {\n      x1: \"400\",\n      y1: \"256\",\n      x2: \"112\",\n      y2: \"256\",\n      style: \"\\n        fill: none;\\n        stroke: currentColor;\\n        stroke-linecap: round;\\n        stroke-linejoin: round;\\n        stroke-width: 32px;\\n      \"\n    }));\n  }\n});","import { createInjectionKey } from \"../../_utils/index.mjs\";\nexport const formInjectionKey = createInjectionKey('n-form');\nexport const formItemInstsInjectionKey = createInjectionKey('n-form-item-insts');","function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\n/* eslint no-console:0 */\nvar formatRegExp = /%[sdj%]/g;\nvar warning = function warning() {}; // don't print warning message when in production env or node runtime\n\nif (typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {\n  warning = function warning(type, errors) {\n    if (typeof console !== 'undefined' && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined') {\n      if (errors.every(function (e) {\n        return typeof e === 'string';\n      })) {\n        console.warn(type, errors);\n      }\n    }\n  };\n}\n\nfunction convertFieldsError(errors) {\n  if (!errors || !errors.length) return null;\n  var fields = {};\n  errors.forEach(function (error) {\n    var field = error.field;\n    fields[field] = fields[field] || [];\n    fields[field].push(error);\n  });\n  return fields;\n}\nfunction format(template) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var i = 0;\n  var len = args.length;\n\n  if (typeof template === 'function') {\n    return template.apply(null, args);\n  }\n\n  if (typeof template === 'string') {\n    var str = template.replace(formatRegExp, function (x) {\n      if (x === '%%') {\n        return '%';\n      }\n\n      if (i >= len) {\n        return x;\n      }\n\n      switch (x) {\n        case '%s':\n          return String(args[i++]);\n\n        case '%d':\n          return Number(args[i++]);\n\n        case '%j':\n          try {\n            return JSON.stringify(args[i++]);\n          } catch (_) {\n            return '[Circular]';\n          }\n\n          break;\n\n        default:\n          return x;\n      }\n    });\n    return str;\n  }\n\n  return template;\n}\n\nfunction isNativeStringType(type) {\n  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';\n}\n\nfunction isEmptyValue(value, type) {\n  if (value === undefined || value === null) {\n    return true;\n  }\n\n  if (type === 'array' && Array.isArray(value) && !value.length) {\n    return true;\n  }\n\n  if (isNativeStringType(type) && typeof value === 'string' && !value) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction asyncParallelArray(arr, func, callback) {\n  var results = [];\n  var total = 0;\n  var arrLength = arr.length;\n\n  function count(errors) {\n    results.push.apply(results, errors || []);\n    total++;\n\n    if (total === arrLength) {\n      callback(results);\n    }\n  }\n\n  arr.forEach(function (a) {\n    func(a, count);\n  });\n}\n\nfunction asyncSerialArray(arr, func, callback) {\n  var index = 0;\n  var arrLength = arr.length;\n\n  function next(errors) {\n    if (errors && errors.length) {\n      callback(errors);\n      return;\n    }\n\n    var original = index;\n    index = index + 1;\n\n    if (original < arrLength) {\n      func(arr[original], next);\n    } else {\n      callback([]);\n    }\n  }\n\n  next([]);\n}\n\nfunction flattenObjArr(objArr) {\n  var ret = [];\n  Object.keys(objArr).forEach(function (k) {\n    ret.push.apply(ret, objArr[k] || []);\n  });\n  return ret;\n}\n\nvar AsyncValidationError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(AsyncValidationError, _Error);\n\n  function AsyncValidationError(errors, fields) {\n    var _this;\n\n    _this = _Error.call(this, 'Async Validation Error') || this;\n    _this.errors = errors;\n    _this.fields = fields;\n    return _this;\n  }\n\n  return AsyncValidationError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nfunction asyncMap(objArr, option, func, callback, source) {\n  if (option.first) {\n    var _pending = new Promise(function (resolve, reject) {\n      var next = function next(errors) {\n        callback(errors);\n        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);\n      };\n\n      var flattenArr = flattenObjArr(objArr);\n      asyncSerialArray(flattenArr, func, next);\n    });\n\n    _pending[\"catch\"](function (e) {\n      return e;\n    });\n\n    return _pending;\n  }\n\n  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];\n  var objArrKeys = Object.keys(objArr);\n  var objArrLength = objArrKeys.length;\n  var total = 0;\n  var results = [];\n  var pending = new Promise(function (resolve, reject) {\n    var next = function next(errors) {\n      results.push.apply(results, errors);\n      total++;\n\n      if (total === objArrLength) {\n        callback(results);\n        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);\n      }\n    };\n\n    if (!objArrKeys.length) {\n      callback(results);\n      resolve(source);\n    }\n\n    objArrKeys.forEach(function (key) {\n      var arr = objArr[key];\n\n      if (firstFields.indexOf(key) !== -1) {\n        asyncSerialArray(arr, func, next);\n      } else {\n        asyncParallelArray(arr, func, next);\n      }\n    });\n  });\n  pending[\"catch\"](function (e) {\n    return e;\n  });\n  return pending;\n}\n\nfunction isErrorObj(obj) {\n  return !!(obj && obj.message !== undefined);\n}\n\nfunction getValue(value, path) {\n  var v = value;\n\n  for (var i = 0; i < path.length; i++) {\n    if (v == undefined) {\n      return v;\n    }\n\n    v = v[path[i]];\n  }\n\n  return v;\n}\n\nfunction complementError(rule, source) {\n  return function (oe) {\n    var fieldValue;\n\n    if (rule.fullFields) {\n      fieldValue = getValue(source, rule.fullFields);\n    } else {\n      fieldValue = source[oe.field || rule.fullField];\n    }\n\n    if (isErrorObj(oe)) {\n      oe.field = oe.field || rule.fullField;\n      oe.fieldValue = fieldValue;\n      return oe;\n    }\n\n    return {\n      message: typeof oe === 'function' ? oe() : oe,\n      fieldValue: fieldValue,\n      field: oe.field || rule.fullField\n    };\n  };\n}\nfunction deepMerge(target, source) {\n  if (source) {\n    for (var s in source) {\n      if (source.hasOwnProperty(s)) {\n        var value = source[s];\n\n        if (typeof value === 'object' && typeof target[s] === 'object') {\n          target[s] = _extends({}, target[s], value);\n        } else {\n          target[s] = value;\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nvar required$1 = function required(rule, value, source, errors, options, type) {\n  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {\n    errors.push(format(options.messages.required, rule.fullField));\n  }\n};\n\n/**\n *  Rule for validating whitespace.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nvar whitespace = function whitespace(rule, value, source, errors, options) {\n  if (/^\\s+$/.test(value) || value === '') {\n    errors.push(format(options.messages.whitespace, rule.fullField));\n  }\n};\n\n// https://github.com/kevva/url-regex/blob/master/index.js\nvar urlReg;\nvar getUrlRegex = (function () {\n  if (urlReg) {\n    return urlReg;\n  }\n\n  var word = '[a-fA-F\\\\d:]';\n\n  var b = function b(options) {\n    return options && options.includeBoundaries ? \"(?:(?<=\\\\s|^)(?=\" + word + \")|(?<=\" + word + \")(?=\\\\s|$))\" : '';\n  };\n\n  var v4 = '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}';\n  var v6seg = '[a-fA-F\\\\d]{1,4}';\n  var v6 = (\"\\n(?:\\n(?:\" + v6seg + \":){7}(?:\" + v6seg + \"|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\\n(?:\" + v6seg + \":){6}(?:\" + v4 + \"|:\" + v6seg + \"|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\\n(?:\" + v6seg + \":){5}(?::\" + v4 + \"|(?::\" + v6seg + \"){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\\n(?:\" + v6seg + \":){4}(?:(?::\" + v6seg + \"){0,1}:\" + v4 + \"|(?::\" + v6seg + \"){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\\n(?:\" + v6seg + \":){3}(?:(?::\" + v6seg + \"){0,2}:\" + v4 + \"|(?::\" + v6seg + \"){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){2}(?:(?::\" + v6seg + \"){0,3}:\" + v4 + \"|(?::\" + v6seg + \"){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){1}(?:(?::\" + v6seg + \"){0,4}:\" + v4 + \"|(?::\" + v6seg + \"){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\\n(?::(?:(?::\" + v6seg + \"){0,5}:\" + v4 + \"|(?::\" + v6seg + \"){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\\n\").replace(/\\s*\\/\\/.*$/gm, '').replace(/\\n/g, '').trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful\n\n  var v46Exact = new RegExp(\"(?:^\" + v4 + \"$)|(?:^\" + v6 + \"$)\");\n  var v4exact = new RegExp(\"^\" + v4 + \"$\");\n  var v6exact = new RegExp(\"^\" + v6 + \"$\");\n\n  var ip = function ip(options) {\n    return options && options.exact ? v46Exact : new RegExp(\"(?:\" + b(options) + v4 + b(options) + \")|(?:\" + b(options) + v6 + b(options) + \")\", 'g');\n  };\n\n  ip.v4 = function (options) {\n    return options && options.exact ? v4exact : new RegExp(\"\" + b(options) + v4 + b(options), 'g');\n  };\n\n  ip.v6 = function (options) {\n    return options && options.exact ? v6exact : new RegExp(\"\" + b(options) + v6 + b(options), 'g');\n  };\n\n  var protocol = \"(?:(?:[a-z]+:)?//)\";\n  var auth = '(?:\\\\S+(?::\\\\S*)?@)?';\n  var ipv4 = ip.v4().source;\n  var ipv6 = ip.v6().source;\n  var host = \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\";\n  var domain = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\";\n  var tld = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\";\n  var port = '(?::\\\\d{2,5})?';\n  var path = '(?:[/?#][^\\\\s\"]*)?';\n  var regex = \"(?:\" + protocol + \"|www\\\\.)\" + auth + \"(?:localhost|\" + ipv4 + \"|\" + ipv6 + \"|\" + host + domain + tld + \")\" + port + path;\n  urlReg = new RegExp(\"(?:^\" + regex + \"$)\", 'i');\n  return urlReg;\n});\n\n/* eslint max-len:0 */\n\nvar pattern$2 = {\n  // http://emailregex.com/\n  email: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+\\.)+[a-zA-Z\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}))$/,\n  // url: new RegExp(\n  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(/|\\\\?|#)[^\\\\s]*)?$',\n  //   'i',\n  // ),\n  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i\n};\nvar types = {\n  integer: function integer(value) {\n    return types.number(value) && parseInt(value, 10) === value;\n  },\n  \"float\": function float(value) {\n    return types.number(value) && !types.integer(value);\n  },\n  array: function array(value) {\n    return Array.isArray(value);\n  },\n  regexp: function regexp(value) {\n    if (value instanceof RegExp) {\n      return true;\n    }\n\n    try {\n      return !!new RegExp(value);\n    } catch (e) {\n      return false;\n    }\n  },\n  date: function date(value) {\n    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());\n  },\n  number: function number(value) {\n    if (isNaN(value)) {\n      return false;\n    }\n\n    return typeof value === 'number';\n  },\n  object: function object(value) {\n    return typeof value === 'object' && !types.array(value);\n  },\n  method: function method(value) {\n    return typeof value === 'function';\n  },\n  email: function email(value) {\n    return typeof value === 'string' && value.length <= 320 && !!value.match(pattern$2.email);\n  },\n  url: function url(value) {\n    return typeof value === 'string' && value.length <= 2048 && !!value.match(getUrlRegex());\n  },\n  hex: function hex(value) {\n    return typeof value === 'string' && !!value.match(pattern$2.hex);\n  }\n};\n\nvar type$1 = function type(rule, value, source, errors, options) {\n  if (rule.required && value === undefined) {\n    required$1(rule, value, source, errors, options);\n    return;\n  }\n\n  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];\n  var ruleType = rule.type;\n\n  if (custom.indexOf(ruleType) > -1) {\n    if (!types[ruleType](value)) {\n      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n    } // straight typeof check\n\n  } else if (ruleType && typeof value !== rule.type) {\n    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n  }\n};\n\nvar range = function range(rule, value, source, errors, options) {\n  var len = typeof rule.len === 'number';\n  var min = typeof rule.min === 'number';\n  var max = typeof rule.max === 'number'; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）\n\n  var spRegexp = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  var val = value;\n  var key = null;\n  var num = typeof value === 'number';\n  var str = typeof value === 'string';\n  var arr = Array.isArray(value);\n\n  if (num) {\n    key = 'number';\n  } else if (str) {\n    key = 'string';\n  } else if (arr) {\n    key = 'array';\n  } // if the value is not of a supported type for range validation\n  // the validation rule rule should use the\n  // type property to also test for a particular type\n\n\n  if (!key) {\n    return false;\n  }\n\n  if (arr) {\n    val = value.length;\n  }\n\n  if (str) {\n    // 处理码点大于U+010000的文字length属性不准确的bug，如\"𠮷𠮷𠮷\".lenght !== 3\n    val = value.replace(spRegexp, '_').length;\n  }\n\n  if (len) {\n    if (val !== rule.len) {\n      errors.push(format(options.messages[key].len, rule.fullField, rule.len));\n    }\n  } else if (min && !max && val < rule.min) {\n    errors.push(format(options.messages[key].min, rule.fullField, rule.min));\n  } else if (max && !min && val > rule.max) {\n    errors.push(format(options.messages[key].max, rule.fullField, rule.max));\n  } else if (min && max && (val < rule.min || val > rule.max)) {\n    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));\n  }\n};\n\nvar ENUM$1 = 'enum';\n\nvar enumerable$1 = function enumerable(rule, value, source, errors, options) {\n  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];\n\n  if (rule[ENUM$1].indexOf(value) === -1) {\n    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(', ')));\n  }\n};\n\nvar pattern$1 = function pattern(rule, value, source, errors, options) {\n  if (rule.pattern) {\n    if (rule.pattern instanceof RegExp) {\n      // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n      // flag is accidentally set to `true`, which in a validation scenario\n      // is not necessary and the result might be misleading\n      rule.pattern.lastIndex = 0;\n\n      if (!rule.pattern.test(value)) {\n        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    } else if (typeof rule.pattern === 'string') {\n      var _pattern = new RegExp(rule.pattern);\n\n      if (!_pattern.test(value)) {\n        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    }\n  }\n};\n\nvar rules = {\n  required: required$1,\n  whitespace: whitespace,\n  type: type$1,\n  range: range,\n  \"enum\": enumerable$1,\n  pattern: pattern$1\n};\n\nvar string = function string(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value, 'string') && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options, 'string');\n\n    if (!isEmptyValue(value, 'string')) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n      rules.pattern(rule, value, source, errors, options);\n\n      if (rule.whitespace === true) {\n        rules.whitespace(rule, value, source, errors, options);\n      }\n    }\n  }\n\n  callback(errors);\n};\n\nvar method = function method(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar number = function number(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (value === '') {\n      value = undefined;\n    }\n\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar _boolean = function _boolean(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar regexp = function regexp(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (!isEmptyValue(value)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar integer = function integer(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar floatFn = function floatFn(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar array = function array(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if ((value === undefined || value === null) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options, 'array');\n\n    if (value !== undefined && value !== null) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar object = function object(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar ENUM = 'enum';\n\nvar enumerable = function enumerable(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules[ENUM](rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar pattern = function pattern(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value, 'string') && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (!isEmptyValue(value, 'string')) {\n      rules.pattern(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar date = function date(rule, value, callback, source, options) {\n  // console.log('integer rule called %j', rule);\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);\n\n  if (validate) {\n    if (isEmptyValue(value, 'date') && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (!isEmptyValue(value, 'date')) {\n      var dateObject;\n\n      if (value instanceof Date) {\n        dateObject = value;\n      } else {\n        dateObject = new Date(value);\n      }\n\n      rules.type(rule, dateObject, source, errors, options);\n\n      if (dateObject) {\n        rules.range(rule, dateObject.getTime(), source, errors, options);\n      }\n    }\n  }\n\n  callback(errors);\n};\n\nvar required = function required(rule, value, callback, source, options) {\n  var errors = [];\n  var type = Array.isArray(value) ? 'array' : typeof value;\n  rules.required(rule, value, source, errors, options, type);\n  callback(errors);\n};\n\nvar type = function type(rule, value, callback, source, options) {\n  var ruleType = rule.type;\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value, ruleType) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options, ruleType);\n\n    if (!isEmptyValue(value, ruleType)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar any = function any(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n  }\n\n  callback(errors);\n};\n\nvar validators = {\n  string: string,\n  method: method,\n  number: number,\n  \"boolean\": _boolean,\n  regexp: regexp,\n  integer: integer,\n  \"float\": floatFn,\n  array: array,\n  object: object,\n  \"enum\": enumerable,\n  pattern: pattern,\n  date: date,\n  url: type,\n  hex: type,\n  email: type,\n  required: required,\n  any: any\n};\n\nfunction newMessages() {\n  return {\n    \"default\": 'Validation error on field %s',\n    required: '%s is required',\n    \"enum\": '%s must be one of %s',\n    whitespace: '%s cannot be empty',\n    date: {\n      format: '%s date %s is invalid for format %s',\n      parse: '%s date could not be parsed, %s is invalid ',\n      invalid: '%s date %s is invalid'\n    },\n    types: {\n      string: '%s is not a %s',\n      method: '%s is not a %s (function)',\n      array: '%s is not an %s',\n      object: '%s is not an %s',\n      number: '%s is not a %s',\n      date: '%s is not a %s',\n      \"boolean\": '%s is not a %s',\n      integer: '%s is not an %s',\n      \"float\": '%s is not a %s',\n      regexp: '%s is not a valid %s',\n      email: '%s is not a valid %s',\n      url: '%s is not a valid %s',\n      hex: '%s is not a valid %s'\n    },\n    string: {\n      len: '%s must be exactly %s characters',\n      min: '%s must be at least %s characters',\n      max: '%s cannot be longer than %s characters',\n      range: '%s must be between %s and %s characters'\n    },\n    number: {\n      len: '%s must equal %s',\n      min: '%s cannot be less than %s',\n      max: '%s cannot be greater than %s',\n      range: '%s must be between %s and %s'\n    },\n    array: {\n      len: '%s must be exactly %s in length',\n      min: '%s cannot be less than %s in length',\n      max: '%s cannot be greater than %s in length',\n      range: '%s must be between %s and %s in length'\n    },\n    pattern: {\n      mismatch: '%s value %s does not match pattern %s'\n    },\n    clone: function clone() {\n      var cloned = JSON.parse(JSON.stringify(this));\n      cloned.clone = this.clone;\n      return cloned;\n    }\n  };\n}\nvar messages = newMessages();\n\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */\n\nvar Schema = /*#__PURE__*/function () {\n  // ========================= Static =========================\n  // ======================== Instance ========================\n  function Schema(descriptor) {\n    this.rules = null;\n    this._messages = messages;\n    this.define(descriptor);\n  }\n\n  var _proto = Schema.prototype;\n\n  _proto.define = function define(rules) {\n    var _this = this;\n\n    if (!rules) {\n      throw new Error('Cannot configure a schema with no rules');\n    }\n\n    if (typeof rules !== 'object' || Array.isArray(rules)) {\n      throw new Error('Rules must be an object');\n    }\n\n    this.rules = {};\n    Object.keys(rules).forEach(function (name) {\n      var item = rules[name];\n      _this.rules[name] = Array.isArray(item) ? item : [item];\n    });\n  };\n\n  _proto.messages = function messages(_messages) {\n    if (_messages) {\n      this._messages = deepMerge(newMessages(), _messages);\n    }\n\n    return this._messages;\n  };\n\n  _proto.validate = function validate(source_, o, oc) {\n    var _this2 = this;\n\n    if (o === void 0) {\n      o = {};\n    }\n\n    if (oc === void 0) {\n      oc = function oc() {};\n    }\n\n    var source = source_;\n    var options = o;\n    var callback = oc;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    if (!this.rules || Object.keys(this.rules).length === 0) {\n      if (callback) {\n        callback(null, source);\n      }\n\n      return Promise.resolve(source);\n    }\n\n    function complete(results) {\n      var errors = [];\n      var fields = {};\n\n      function add(e) {\n        if (Array.isArray(e)) {\n          var _errors;\n\n          errors = (_errors = errors).concat.apply(_errors, e);\n        } else {\n          errors.push(e);\n        }\n      }\n\n      for (var i = 0; i < results.length; i++) {\n        add(results[i]);\n      }\n\n      if (!errors.length) {\n        callback(null, source);\n      } else {\n        fields = convertFieldsError(errors);\n        callback(errors, fields);\n      }\n    }\n\n    if (options.messages) {\n      var messages$1 = this.messages();\n\n      if (messages$1 === messages) {\n        messages$1 = newMessages();\n      }\n\n      deepMerge(messages$1, options.messages);\n      options.messages = messages$1;\n    } else {\n      options.messages = this.messages();\n    }\n\n    var series = {};\n    var keys = options.keys || Object.keys(this.rules);\n    keys.forEach(function (z) {\n      var arr = _this2.rules[z];\n      var value = source[z];\n      arr.forEach(function (r) {\n        var rule = r;\n\n        if (typeof rule.transform === 'function') {\n          if (source === source_) {\n            source = _extends({}, source);\n          }\n\n          value = source[z] = rule.transform(value);\n        }\n\n        if (typeof rule === 'function') {\n          rule = {\n            validator: rule\n          };\n        } else {\n          rule = _extends({}, rule);\n        } // Fill validator. Skip if nothing need to validate\n\n\n        rule.validator = _this2.getValidationMethod(rule);\n\n        if (!rule.validator) {\n          return;\n        }\n\n        rule.field = z;\n        rule.fullField = rule.fullField || z;\n        rule.type = _this2.getType(rule);\n        series[z] = series[z] || [];\n        series[z].push({\n          rule: rule,\n          value: value,\n          source: source,\n          field: z\n        });\n      });\n    });\n    var errorFields = {};\n    return asyncMap(series, options, function (data, doIt) {\n      var rule = data.rule;\n      var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');\n      deep = deep && (rule.required || !rule.required && data.value);\n      rule.field = data.field;\n\n      function addFullField(key, schema) {\n        return _extends({}, schema, {\n          fullField: rule.fullField + \".\" + key,\n          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]\n        });\n      }\n\n      function cb(e) {\n        if (e === void 0) {\n          e = [];\n        }\n\n        var errorList = Array.isArray(e) ? e : [e];\n\n        if (!options.suppressWarning && errorList.length) {\n          Schema.warning('async-validator:', errorList);\n        }\n\n        if (errorList.length && rule.message !== undefined) {\n          errorList = [].concat(rule.message);\n        } // Fill error info\n\n\n        var filledErrors = errorList.map(complementError(rule, source));\n\n        if (options.first && filledErrors.length) {\n          errorFields[rule.field] = 1;\n          return doIt(filledErrors);\n        }\n\n        if (!deep) {\n          doIt(filledErrors);\n        } else {\n          // if rule is required but the target object\n          // does not exist fail at the rule level and don't\n          // go deeper\n          if (rule.required && !data.value) {\n            if (rule.message !== undefined) {\n              filledErrors = [].concat(rule.message).map(complementError(rule, source));\n            } else if (options.error) {\n              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];\n            }\n\n            return doIt(filledErrors);\n          }\n\n          var fieldsSchema = {};\n\n          if (rule.defaultField) {\n            Object.keys(data.value).map(function (key) {\n              fieldsSchema[key] = rule.defaultField;\n            });\n          }\n\n          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);\n          var paredFieldsSchema = {};\n          Object.keys(fieldsSchema).forEach(function (field) {\n            var fieldSchema = fieldsSchema[field];\n            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];\n            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));\n          });\n          var schema = new Schema(paredFieldsSchema);\n          schema.messages(options.messages);\n\n          if (data.rule.options) {\n            data.rule.options.messages = options.messages;\n            data.rule.options.error = options.error;\n          }\n\n          schema.validate(data.value, data.rule.options || options, function (errs) {\n            var finalErrors = [];\n\n            if (filledErrors && filledErrors.length) {\n              finalErrors.push.apply(finalErrors, filledErrors);\n            }\n\n            if (errs && errs.length) {\n              finalErrors.push.apply(finalErrors, errs);\n            }\n\n            doIt(finalErrors.length ? finalErrors : null);\n          });\n        }\n      }\n\n      var res;\n\n      if (rule.asyncValidator) {\n        res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n      } else if (rule.validator) {\n        try {\n          res = rule.validator(rule, data.value, cb, data.source, options);\n        } catch (error) {\n          console.error == null ? void 0 : console.error(error); // rethrow to report error\n\n          if (!options.suppressValidatorError) {\n            setTimeout(function () {\n              throw error;\n            }, 0);\n          }\n\n          cb(error.message);\n        }\n\n        if (res === true) {\n          cb();\n        } else if (res === false) {\n          cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + \" fails\");\n        } else if (res instanceof Array) {\n          cb(res);\n        } else if (res instanceof Error) {\n          cb(res.message);\n        }\n      }\n\n      if (res && res.then) {\n        res.then(function () {\n          return cb();\n        }, function (e) {\n          return cb(e);\n        });\n      }\n    }, function (results) {\n      complete(results);\n    }, source);\n  };\n\n  _proto.getType = function getType(rule) {\n    if (rule.type === undefined && rule.pattern instanceof RegExp) {\n      rule.type = 'pattern';\n    }\n\n    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {\n      throw new Error(format('Unknown rule type %s', rule.type));\n    }\n\n    return rule.type || 'string';\n  };\n\n  _proto.getValidationMethod = function getValidationMethod(rule) {\n    if (typeof rule.validator === 'function') {\n      return rule.validator;\n    }\n\n    var keys = Object.keys(rule);\n    var messageIndex = keys.indexOf('message');\n\n    if (messageIndex !== -1) {\n      keys.splice(messageIndex, 1);\n    }\n\n    if (keys.length === 1 && keys[0] === 'required') {\n      return validators.required;\n    }\n\n    return validators[this.getType(rule)] || undefined;\n  };\n\n  return Schema;\n}();\n\nSchema.register = function register(type, validator) {\n  if (typeof validator !== 'function') {\n    throw new Error('Cannot register a validator by type, validator is not a function');\n  }\n\n  validators[type] = validator;\n};\n\nSchema.warning = warning;\nSchema.messages = messages;\nSchema.validators = validators;\n\nexport { Schema as default };\n//# sourceMappingURL=index.js.map\n","import { c } from \"../../_utils/cssr/index.mjs\";\nimport commonVariables from \"../common/_common.mjs\";\nconst {\n  cubicBezierEaseInOut\n} = commonVariables;\nexport function fadeDownTransition({\n  name = 'fade-down',\n  fromOffset = '-4px',\n  enterDuration = '.3s',\n  leaveDuration = '.3s',\n  enterCubicBezier = cubicBezierEaseInOut,\n  leaveCubicBezier = cubicBezierEaseInOut\n} = {}) {\n  return [c(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {\n    opacity: 0,\n    transform: `translateY(${fromOffset})`\n  }), c(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {\n    opacity: 1,\n    transform: 'translateY(0)'\n  }), c(`&.${name}-transition-leave-active`, {\n    transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`\n  }), c(`&.${name}-transition-enter-active`, {\n    transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`\n  })];\n}","import { cB, cE, cM, c } from \"../../../_utils/cssr/index.mjs\";\nimport { fadeDownTransition } from \"../../../_styles/transitions/fade-down.cssr.mjs\";\n// vars:\n// --n-line-height\n// --n-blank-height\n// --n-feedback-padding\n// --n-feedback-font-size\n// --n-label-font-size-left\n// --n-label-font-size-top\n// --n-label-height\n// --n-label-padding\n// --n-asterisk-color\n// --n-label-text-color\n// --n-bezier\n// --n-feedback-text-color\n// --n-feedback-text-color-warning\n// --n-feedback-text-color-error\n// --n-label-text-align\n// --n-label-padding\nexport default cB('form-item', `\n display: grid;\n line-height: var(--n-line-height);\n`, [cB('form-item-label', `\n grid-area: label;\n align-items: center;\n line-height: 1.25;\n text-align: var(--n-label-text-align);\n font-size: var(--n-label-font-size);\n min-height: var(--n-label-height);\n padding: var(--n-label-padding);\n color: var(--n-label-text-color);\n transition: color .3s var(--n-bezier);\n box-sizing: border-box;\n font-weight: var(--n-label-font-weight);\n `, [cE('asterisk', `\n white-space: nowrap;\n user-select: none;\n -webkit-user-select: none;\n color: var(--n-asterisk-color);\n transition: color .3s var(--n-bezier);\n `), cE('asterisk-placeholder', `\n grid-area: mark;\n user-select: none;\n -webkit-user-select: none;\n visibility: hidden; \n `)]), cB('form-item-blank', `\n grid-area: blank;\n min-height: var(--n-blank-height);\n `), cM('auto-label-width', [cB('form-item-label', 'white-space: nowrap;')]), cM('left-labelled', `\n grid-template-areas:\n \"label blank\"\n \"label feedback\";\n grid-template-columns: auto minmax(0, 1fr);\n grid-template-rows: auto 1fr;\n align-items: flex-start;\n `, [cB('form-item-label', `\n display: grid;\n grid-template-columns: 1fr auto;\n min-height: var(--n-blank-height);\n height: auto;\n box-sizing: border-box;\n flex-shrink: 0;\n flex-grow: 0;\n `, [cM('reverse-columns-space', `\n grid-template-columns: auto 1fr;\n `), cM('left-mark', `\n grid-template-areas:\n \"mark text\"\n \". text\";\n `), cM('right-mark', `\n grid-template-areas: \n \"text mark\"\n \"text .\";\n `), cM('right-hanging-mark', `\n grid-template-areas: \n \"text mark\"\n \"text .\";\n `), cE('text', `\n grid-area: text; \n `), cE('asterisk', `\n grid-area: mark; \n align-self: end;\n `)])]), cM('top-labelled', `\n grid-template-areas:\n \"label\"\n \"blank\"\n \"feedback\";\n grid-template-rows: minmax(var(--n-label-height), auto) 1fr;\n grid-template-columns: minmax(0, 100%);\n `, [cM('no-label', `\n grid-template-areas:\n \"blank\"\n \"feedback\";\n grid-template-rows: 1fr;\n `), cB('form-item-label', `\n display: flex;\n align-items: flex-start;\n justify-content: var(--n-label-text-align);\n `)]), cB('form-item-blank', `\n box-sizing: border-box;\n display: flex;\n align-items: center;\n position: relative;\n `), cB('form-item-feedback-wrapper', `\n grid-area: feedback;\n box-sizing: border-box;\n min-height: var(--n-feedback-height);\n font-size: var(--n-feedback-font-size);\n line-height: 1.25;\n transform-origin: top left;\n `, [c('&:not(:empty)', `\n padding: var(--n-feedback-padding);\n `), cB('form-item-feedback', {\n  transition: 'color .3s var(--n-bezier)',\n  color: 'var(--n-feedback-text-color)'\n}, [cM('warning', {\n  color: 'var(--n-feedback-text-color-warning)'\n}), cM('error', {\n  color: 'var(--n-feedback-text-color-error)'\n}), fadeDownTransition({\n  fromOffset: '-3px',\n  enterDuration: '.3s',\n  leaveDuration: '.2s'\n})])])]);","var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { h, defineComponent, computed, toRef, ref, provide, inject, watch, Transition, onMounted } from 'vue';\nimport Schema from 'async-validator';\nimport { get } from 'lodash-es';\nimport { createId } from 'seemly';\nimport { formItemInjectionKey } from \"../../_mixins/use-form-item.mjs\";\nimport { useConfig, useTheme, useThemeClass } from \"../../_mixins/index.mjs\";\nimport { warn, createKey, useInjectionInstanceCollection, keysOf, resolveWrappedSlot } from \"../../_utils/index.mjs\";\nimport { formLight } from \"../styles/index.mjs\";\nimport { formItemMisc, formItemSize, formItemRule } from \"./utils.mjs\";\nimport { formInjectionKey, formItemInstsInjectionKey } from \"./context.mjs\";\nimport style from \"./styles/form-item.cssr.mjs\";\nexport const formItemProps = Object.assign(Object.assign({}, useTheme.props), {\n  label: String,\n  labelWidth: [Number, String],\n  labelStyle: [String, Object],\n  labelAlign: String,\n  labelPlacement: String,\n  path: String,\n  first: Boolean,\n  rulePath: String,\n  required: Boolean,\n  showRequireMark: {\n    type: Boolean,\n    default: undefined\n  },\n  requireMarkPlacement: String,\n  showFeedback: {\n    type: Boolean,\n    default: undefined\n  },\n  rule: [Object, Array],\n  size: String,\n  ignorePathChange: Boolean,\n  validationStatus: String,\n  feedback: String,\n  showLabel: {\n    type: Boolean,\n    default: undefined\n  },\n  labelProps: Object\n});\nexport const formItemPropKeys = keysOf(formItemProps);\n// wrap sync validator\nfunction wrapValidator(validator, async) {\n  return (...args) => {\n    try {\n      const validateResult = validator(...args);\n      if (!async && (typeof validateResult === 'boolean' || validateResult instanceof Error || Array.isArray(validateResult)) || (\n      // Error[]\n      validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {\n        return validateResult;\n      } else if (validateResult === undefined) {\n        return true;\n      } else {\n        warn('form-item/validate', `You return a ${typeof validateResult} ` + 'typed value in the validator method, which is not recommended. Please use ' + (async ? '`Promise`' : '`boolean`, `Error` or `Promise`') + ' typed value instead.');\n        return true;\n      }\n    } catch (err) {\n      warn('form-item/validate', 'An error is catched in the validation, ' + \"so the validation won't be done. Your callback in `validate` method of \" + \"`n-form` or `n-form-item` won't be called in this validation.\");\n      console.error(err);\n      // If returns undefined, async-validator won't trigger callback\n      // so the result will be abandoned, which means not true and not false\n      return undefined;\n    }\n  };\n}\nexport default defineComponent({\n  name: 'FormItem',\n  props: formItemProps,\n  setup(props) {\n    useInjectionInstanceCollection(formItemInstsInjectionKey, 'formItems', toRef(props, 'path'));\n    const {\n      mergedClsPrefixRef,\n      inlineThemeDisabled\n    } = useConfig(props);\n    const NForm = inject(formInjectionKey, null);\n    const formItemSizeRefs = formItemSize(props);\n    const formItemMiscRefs = formItemMisc(props);\n    const {\n      validationErrored: validationErroredRef,\n      validationWarned: validationWarnedRef\n    } = formItemMiscRefs;\n    const {\n      mergedRequired: mergedRequiredRef,\n      mergedRules: mergedRulesRef\n    } = formItemRule(props);\n    const {\n      mergedSize: mergedSizeRef\n    } = formItemSizeRefs;\n    const {\n      mergedLabelPlacement: labelPlacementRef,\n      mergedLabelAlign: labelTextAlignRef,\n      mergedRequireMarkPlacement: mergedRequireMarkPlacementRef\n    } = formItemMiscRefs;\n    const renderExplainsRef = ref([]);\n    const feedbackIdRef = ref(createId());\n    const mergedDisabledRef = NForm ? toRef(NForm.props, 'disabled') : ref(false);\n    const themeRef = useTheme('Form', '-form-item', style, formLight, props, mergedClsPrefixRef);\n    watch(toRef(props, 'path'), () => {\n      if (props.ignorePathChange) return;\n      restoreValidation();\n    });\n    function restoreValidation() {\n      renderExplainsRef.value = [];\n      validationErroredRef.value = false;\n      validationWarnedRef.value = false;\n      if (props.feedback) {\n        feedbackIdRef.value = createId();\n      }\n    }\n    function handleContentBlur() {\n      void internalValidate('blur');\n    }\n    function handleContentChange() {\n      void internalValidate('change');\n    }\n    function handleContentFocus() {\n      void internalValidate('focus');\n    }\n    function handleContentInput() {\n      void internalValidate('input');\n    }\n    function validate(options, callback) {\n      return __awaiter(this, void 0, void 0, function* () {\n        /** the following code is for compatibility */\n        let trigger;\n        let validateCallback;\n        let shouldRuleBeApplied;\n        let asyncValidatorOptions;\n        if (typeof options === 'string') {\n          trigger = options;\n          validateCallback = callback;\n        } else if (options !== null && typeof options === 'object') {\n          trigger = options.trigger;\n          validateCallback = options.callback;\n          shouldRuleBeApplied = options.shouldRuleBeApplied;\n          asyncValidatorOptions = options.options;\n        }\n        return yield new Promise((resolve, reject) => {\n          void internalValidate(trigger, shouldRuleBeApplied, asyncValidatorOptions).then(({\n            valid,\n            errors,\n            warnings\n          }) => {\n            if (valid) {\n              if (validateCallback) {\n                validateCallback(undefined, {\n                  warnings\n                });\n              }\n              resolve({\n                warnings\n              });\n            } else {\n              if (validateCallback) {\n                validateCallback(errors, {\n                  warnings\n                });\n              }\n              reject(errors);\n            }\n          });\n        });\n      });\n    }\n    const internalValidate = (trigger = null, shouldRuleBeApplied = () => true, options = {\n      suppressWarning: true\n    }) => __awaiter(this, void 0, void 0, function* () {\n      const {\n        path\n      } = props;\n      if (!options) {\n        options = {};\n      } else {\n        if (!options.first) options.first = props.first;\n      }\n      const {\n        value: rules\n      } = mergedRulesRef;\n      const value = NForm ? get(NForm.props.model, path || '') : undefined;\n      const messageRenderers = {};\n      const originalMessageRendersMessage = {};\n      const activeRules = (!trigger ? rules : rules.filter(rule => {\n        if (Array.isArray(rule.trigger)) {\n          return rule.trigger.includes(trigger);\n        } else {\n          return rule.trigger === trigger;\n        }\n      })).filter(shouldRuleBeApplied).map((rule, i) => {\n        const shallowClonedRule = Object.assign({}, rule);\n        if (shallowClonedRule.validator) {\n          shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);\n        }\n        if (shallowClonedRule.asyncValidator) {\n          shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);\n        }\n        if (shallowClonedRule.renderMessage) {\n          const rendererKey = `__renderMessage__${i}`;\n          originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;\n          shallowClonedRule.message = rendererKey;\n          messageRenderers[rendererKey] = shallowClonedRule.renderMessage;\n        }\n        return shallowClonedRule;\n      });\n      const activeErrorRules = activeRules.filter(r => r.level !== 'warning');\n      const activeWarningRules = activeRules.filter(r => r.level === 'warning');\n      const mergedPath = path !== null && path !== void 0 ? path : '__n_no_path__';\n      const validator = new Schema({\n        [mergedPath]: activeErrorRules\n      });\n      const warningValidator = new Schema({\n        [mergedPath]: activeWarningRules\n      });\n      const {\n        validateMessages\n      } = (NForm === null || NForm === void 0 ? void 0 : NForm.props) || {};\n      if (validateMessages) {\n        validator.messages(validateMessages);\n        warningValidator.messages(validateMessages);\n      }\n      const renderMessages = errors => {\n        renderExplainsRef.value = errors.map(error => {\n          const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || '';\n          return {\n            key: transformedMessage,\n            render: () => {\n              if (transformedMessage.startsWith('__renderMessage__')) {\n                return messageRenderers[transformedMessage]();\n              }\n              return transformedMessage;\n            }\n          };\n        });\n        errors.forEach(error => {\n          var _a;\n          if ((_a = error.message) === null || _a === void 0 ? void 0 : _a.startsWith('__renderMessage__')) {\n            error.message = originalMessageRendersMessage[error.message];\n          }\n        });\n      };\n      const validationResult = {\n        valid: true,\n        errors: undefined,\n        warnings: undefined\n      };\n      if (activeErrorRules.length) {\n        const errors = yield new Promise(resolve => {\n          void validator.validate({\n            [mergedPath]: value\n          }, options, resolve);\n        });\n        if (errors === null || errors === void 0 ? void 0 : errors.length) {\n          validationErroredRef.value = true;\n          validationResult.valid = false;\n          validationResult.errors = errors;\n          renderMessages(errors);\n        }\n      }\n      // if there are already errors, warning check can be skipped\n      if (activeWarningRules.length && !validationResult.errors) {\n        const warnings = yield new Promise(resolve => {\n          void warningValidator.validate({\n            [mergedPath]: value\n          }, options, resolve);\n        });\n        if (warnings === null || warnings === void 0 ? void 0 : warnings.length) {\n          renderMessages(warnings);\n          validationWarnedRef.value = true;\n          validationResult.warnings = warnings;\n        }\n      }\n      if (activeErrorRules.length + activeWarningRules.length > 0 && !validationResult.errors && !validationResult.warnings) {\n        restoreValidation();\n      }\n      return validationResult;\n    });\n    provide(formItemInjectionKey, {\n      path: toRef(props, 'path'),\n      disabled: mergedDisabledRef,\n      mergedSize: formItemSizeRefs.mergedSize,\n      mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,\n      restoreValidation,\n      handleContentBlur,\n      handleContentChange,\n      handleContentFocus,\n      handleContentInput\n    });\n    const exposedRef = {\n      validate,\n      restoreValidation,\n      internalValidate\n    };\n    const labelElementRef = ref(null);\n    onMounted(() => {\n      if (!formItemMiscRefs.isAutoLabelWidth.value) return;\n      const labelElement = labelElementRef.value;\n      if (labelElement !== null) {\n        const memoizedWhitespace = labelElement.style.whiteSpace;\n        labelElement.style.whiteSpace = 'nowrap';\n        labelElement.style.width = '';\n        NForm === null || NForm === void 0 ? void 0 : NForm.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));\n        labelElement.style.whiteSpace = memoizedWhitespace;\n      }\n    });\n    const cssVarsRef = computed(() => {\n      var _a;\n      const {\n        value: size\n      } = mergedSizeRef;\n      const {\n        value: labelPlacement\n      } = labelPlacementRef;\n      const direction = labelPlacement === 'top' ? 'vertical' : 'horizontal';\n      const {\n        common: {\n          cubicBezierEaseInOut\n        },\n        self: {\n          labelTextColor,\n          asteriskColor,\n          lineHeight,\n          feedbackTextColor,\n          feedbackTextColorWarning,\n          feedbackTextColorError,\n          feedbackPadding,\n          labelFontWeight,\n          [createKey('labelHeight', size)]: labelHeight,\n          [createKey('blankHeight', size)]: blankHeight,\n          [createKey('feedbackFontSize', size)]: feedbackFontSize,\n          [createKey('feedbackHeight', size)]: feedbackHeight,\n          [createKey('labelPadding', direction)]: labelPadding,\n          [createKey('labelTextAlign', direction)]: labelTextAlign,\n          [createKey(createKey('labelFontSize', labelPlacement), size)]: labelFontSize\n        }\n      } = themeRef.value;\n      let mergedLabelTextAlign = (_a = labelTextAlignRef.value) !== null && _a !== void 0 ? _a : labelTextAlign;\n      if (labelPlacement === 'top') {\n        mergedLabelTextAlign = mergedLabelTextAlign === 'right' ? 'flex-end' : 'flex-start';\n      }\n      const cssVars = {\n        '--n-bezier': cubicBezierEaseInOut,\n        '--n-line-height': lineHeight,\n        '--n-blank-height': blankHeight,\n        '--n-label-font-size': labelFontSize,\n        '--n-label-text-align': mergedLabelTextAlign,\n        '--n-label-height': labelHeight,\n        '--n-label-padding': labelPadding,\n        '--n-label-font-weight': labelFontWeight,\n        '--n-asterisk-color': asteriskColor,\n        '--n-label-text-color': labelTextColor,\n        '--n-feedback-padding': feedbackPadding,\n        '--n-feedback-font-size': feedbackFontSize,\n        '--n-feedback-height': feedbackHeight,\n        '--n-feedback-text-color': feedbackTextColor,\n        '--n-feedback-text-color-warning': feedbackTextColorWarning,\n        '--n-feedback-text-color-error': feedbackTextColorError\n      };\n      return cssVars;\n    });\n    const themeClassHandle = inlineThemeDisabled ? useThemeClass('form-item', computed(() => {\n      var _a;\n      return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a = labelTextAlignRef.value) === null || _a === void 0 ? void 0 : _a[0]) || ''}`;\n    }), cssVarsRef, props) : undefined;\n    const reverseColSpaceRef = computed(() => {\n      // label placement left\n      // require-mark-placement | label align | areas (1fr auto)\n      // left                   | left        | mark text (need reverse)\n      // left                   | right       | mark text (okay)\n      // right                  | left        | mark text (okay)\n      // right                  | right       | mark text (okay)\n      // right-hanging          | left        | text mark (okay)\n      // right-hanging          | right       | text mark (okay)\n      return labelPlacementRef.value === 'left' && mergedRequireMarkPlacementRef.value === 'left' && labelTextAlignRef.value === 'left';\n    });\n    return Object.assign(Object.assign(Object.assign(Object.assign({\n      labelElementRef,\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedRequired: mergedRequiredRef,\n      feedbackId: feedbackIdRef,\n      renderExplains: renderExplainsRef,\n      reverseColSpace: reverseColSpaceRef\n    }, formItemMiscRefs), formItemSizeRefs), exposedRef), {\n      cssVars: inlineThemeDisabled ? undefined : cssVarsRef,\n      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,\n      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender\n    });\n  },\n  render() {\n    const {\n      $slots,\n      mergedClsPrefix,\n      mergedShowLabel,\n      mergedShowRequireMark,\n      mergedRequireMarkPlacement,\n      onRender\n    } = this;\n    const renderedShowRequireMark = mergedShowRequireMark !== undefined ? mergedShowRequireMark : this.mergedRequired;\n    onRender === null || onRender === void 0 ? void 0 : onRender();\n    const renderLabel = () => {\n      const labelText = this.$slots.label ? this.$slots.label() : this.label;\n      if (!labelText) return null;\n      const textNode = h(\"span\", {\n        class: `${mergedClsPrefix}-form-item-label__text`\n      }, labelText);\n      const markNode = renderedShowRequireMark ? h(\"span\", {\n        class: `${mergedClsPrefix}-form-item-label__asterisk`\n      }, mergedRequireMarkPlacement !== 'left' ? '\\u00A0*' : '*\\u00A0') : mergedRequireMarkPlacement === 'right-hanging' && h(\"span\", {\n        class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder`\n      }, '\\u00A0*');\n      const {\n        labelProps\n      } = this;\n      return h(\"label\", Object.assign({}, labelProps, {\n        class: [labelProps === null || labelProps === void 0 ? void 0 : labelProps.class, `${mergedClsPrefix}-form-item-label`, `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`, this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`],\n        style: this.mergedLabelStyle,\n        ref: \"labelElementRef\"\n      }), mergedRequireMarkPlacement === 'left' ? [markNode, textNode] : [textNode, markNode]);\n    };\n    return h(\"div\", {\n      class: [`${mergedClsPrefix}-form-item`, this.themeClass, `${mergedClsPrefix}-form-item--${this.mergedSize}-size`, `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`, !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`],\n      style: this.cssVars\n    }, mergedShowLabel && renderLabel(), h(\"div\", {\n      class: [`${mergedClsPrefix}-form-item-blank`, this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`]\n    }, $slots), this.mergedShowFeedback ? h(\"div\", {\n      key: this.feedbackId,\n      class: `${mergedClsPrefix}-form-item-feedback-wrapper`\n    }, h(Transition, {\n      name: \"fade-down-transition\",\n      mode: \"out-in\"\n    }, {\n      default: () => {\n        const {\n          mergedValidationStatus\n        } = this;\n        return resolveWrappedSlot($slots.feedback, children => {\n          var _a;\n          const {\n            feedback\n          } = this;\n          const feedbackNodes = children || feedback ? h(\"div\", {\n            key: \"__feedback__\",\n            class: `${mergedClsPrefix}-form-item-feedback__line`\n          }, children || feedback) : this.renderExplains.length ? (_a = this.renderExplains) === null || _a === void 0 ? void 0 : _a.map(({\n            key,\n            render\n          }) => h(\"div\", {\n            key: key,\n            class: `${mergedClsPrefix}-form-item-feedback__line`\n          }, render())) : null;\n          return feedbackNodes ? mergedValidationStatus === 'warning' ? h(\"div\", {\n            key: \"controlled-warning\",\n            class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning`\n          }, feedbackNodes) : mergedValidationStatus === 'error' ? h(\"div\", {\n            key: \"controlled-error\",\n            class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error`\n          }, feedbackNodes) : mergedValidationStatus === 'success' ? h(\"div\", {\n            key: \"controlled-success\",\n            class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success`\n          }, feedbackNodes) : h(\"div\", {\n            key: \"controlled-default\",\n            class: `${mergedClsPrefix}-form-item-feedback`\n          }, feedbackNodes) : null;\n        });\n      }\n    })) : null);\n  }\n});","import { inject, computed, ref } from 'vue';\nimport { get } from 'lodash-es';\nimport { formInjectionKey } from \"./context.mjs\";\nimport { formatLength } from \"../../_utils/index.mjs\";\nexport function formItemSize(props) {\n  const NForm = inject(formInjectionKey, null);\n  return {\n    mergedSize: computed(() => {\n      if (props.size !== undefined) return props.size;\n      if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.size) !== undefined) return NForm.props.size;\n      return 'medium';\n    })\n  };\n}\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function formItemMisc(props) {\n  const NForm = inject(formInjectionKey, null);\n  const mergedLabelPlacementRef = computed(() => {\n    const {\n      labelPlacement\n    } = props;\n    if (labelPlacement !== undefined) return labelPlacement;\n    if (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelPlacement) return NForm.props.labelPlacement;\n    return 'top';\n  });\n  const isAutoLabelWidthRef = computed(() => {\n    return mergedLabelPlacementRef.value === 'left' && (props.labelWidth === 'auto' || (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) === 'auto');\n  });\n  const mergedLabelWidthRef = computed(() => {\n    if (mergedLabelPlacementRef.value === 'top') return;\n    const {\n      labelWidth\n    } = props;\n    if (labelWidth !== undefined && labelWidth !== 'auto') {\n      return formatLength(labelWidth);\n    }\n    if (isAutoLabelWidthRef.value) {\n      const autoComputedWidth = NForm === null || NForm === void 0 ? void 0 : NForm.maxChildLabelWidthRef.value;\n      if (autoComputedWidth !== undefined) {\n        return formatLength(autoComputedWidth);\n      } else {\n        return undefined;\n      }\n    }\n    if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) !== undefined) {\n      return formatLength(NForm.props.labelWidth);\n    }\n    return undefined;\n  });\n  const mergedLabelAlignRef = computed(() => {\n    const {\n      labelAlign\n    } = props;\n    if (labelAlign) return labelAlign;\n    if (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelAlign) return NForm.props.labelAlign;\n    return undefined;\n  });\n  const mergedLabelStyleRef = computed(() => {\n    var _a;\n    return [(_a = props.labelProps) === null || _a === void 0 ? void 0 : _a.style, props.labelStyle, {\n      width: mergedLabelWidthRef.value\n    }];\n  });\n  const mergedShowRequireMarkRef = computed(() => {\n    const {\n      showRequireMark\n    } = props;\n    if (showRequireMark !== undefined) return showRequireMark;\n    return NForm === null || NForm === void 0 ? void 0 : NForm.props.showRequireMark;\n  });\n  const mergedRequireMarkPlacementRef = computed(() => {\n    const {\n      requireMarkPlacement\n    } = props;\n    if (requireMarkPlacement !== undefined) return requireMarkPlacement;\n    return (NForm === null || NForm === void 0 ? void 0 : NForm.props.requireMarkPlacement) || 'right';\n  });\n  const validationErroredRef = ref(false);\n  const validationWarnedRef = ref(false);\n  const mergedValidationStatusRef = computed(() => {\n    const {\n      validationStatus\n    } = props;\n    if (validationStatus !== undefined) return validationStatus;\n    if (validationErroredRef.value) return 'error';\n    if (validationWarnedRef.value) return 'warning';\n    return undefined;\n  });\n  const mergedShowFeedbackRef = computed(() => {\n    const {\n      showFeedback\n    } = props;\n    if (showFeedback !== undefined) return showFeedback;\n    if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showFeedback) !== undefined) return NForm.props.showFeedback;\n    return true;\n  });\n  const mergedShowLabelRef = computed(() => {\n    const {\n      showLabel\n    } = props;\n    if (showLabel !== undefined) return showLabel;\n    if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showLabel) !== undefined) return NForm.props.showLabel;\n    return true;\n  });\n  return {\n    validationErrored: validationErroredRef,\n    validationWarned: validationWarnedRef,\n    mergedLabelStyle: mergedLabelStyleRef,\n    mergedLabelPlacement: mergedLabelPlacementRef,\n    mergedLabelAlign: mergedLabelAlignRef,\n    mergedShowRequireMark: mergedShowRequireMarkRef,\n    mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,\n    mergedValidationStatus: mergedValidationStatusRef,\n    mergedShowFeedback: mergedShowFeedbackRef,\n    mergedShowLabel: mergedShowLabelRef,\n    isAutoLabelWidth: isAutoLabelWidthRef\n  };\n}\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function formItemRule(props) {\n  const NForm = inject(formInjectionKey, null);\n  const compatibleRulePathRef = computed(() => {\n    const {\n      rulePath\n    } = props;\n    if (rulePath !== undefined) return rulePath;\n    const {\n      path\n    } = props;\n    if (path !== undefined) return path;\n    return undefined;\n  });\n  const mergedRulesRef = computed(() => {\n    const rules = [];\n    const {\n      rule\n    } = props;\n    if (rule !== undefined) {\n      if (Array.isArray(rule)) rules.push(...rule);else rules.push(rule);\n    }\n    if (NForm) {\n      const {\n        rules: formRules\n      } = NForm.props;\n      const {\n        value: rulePath\n      } = compatibleRulePathRef;\n      if (formRules !== undefined && rulePath !== undefined) {\n        const formRule = get(formRules, rulePath);\n        if (formRule !== undefined) {\n          if (Array.isArray(formRule)) {\n            rules.push(...formRule);\n          } else {\n            // terminate object must be a form item rule\n            rules.push(formRule);\n          }\n        }\n      }\n    }\n    return rules;\n  });\n  const hasRequiredRuleRef = computed(() => {\n    return mergedRulesRef.value.some(rule => rule.required);\n  });\n  // deprecated\n  const mergedRequiredRef = computed(() => {\n    return hasRequiredRuleRef.value || props.required;\n  });\n  return {\n    mergedRules: mergedRulesRef,\n    mergedRequired: mergedRequiredRef\n  };\n}","import { buttonLight } from \"../../button/styles/index.mjs\";\nimport { inputLight } from \"../../input/styles/index.mjs\";\nimport { commonLight } from \"../../_styles/common/index.mjs\";\nimport { createTheme } from \"../../_mixins/index.mjs\";\nconst self = vars => {\n  const {\n    textColorDisabled\n  } = vars;\n  return {\n    iconColorDisabled: textColorDisabled\n  };\n};\nconst inputNumberLight = createTheme({\n  name: 'InputNumber',\n  common: commonLight,\n  peers: {\n    Button: buttonLight,\n    Input: inputLight\n  },\n  self\n});\nexport default inputNumberLight;","// string => string (expected, not implemented)\n// string => number (legacy)\nexport function parse(value) {\n  if (value === undefined || value === null || typeof value === 'string' && value.trim() === '') {\n    return null;\n  }\n  return Number(value);\n}\n// can be parsed to number but shouldn't be applied when inputing\n// when value includes `.`, ending with 0 and`.`, doesn't update, if 0 parse func will remove 0\nexport function isWipValue(value) {\n  return value.includes('.') && (/^(-)?\\d+.*(\\.|0)$/.test(value) || /^\\.\\d+$/.test(value));\n}\n// string => boolean (expected, not implemented)\n// number => boolean (legacy)\nexport function validator(value) {\n  if (value === undefined || value === null) return true;\n  if (Number.isNaN(value)) return false;\n  return true;\n}\n// string => string (expected, not implemented)\n// number => string (legacy)\nexport function format(value, precision) {\n  if (value === undefined || value === null) return '';\n  return precision === undefined ? String(value) : value.toFixed(precision);\n}\nexport function parseNumber(number) {\n  if (number === null) return null;\n  if (typeof number === 'number') {\n    return number;\n  } else {\n    const parsedNumber = Number(number);\n    if (Number.isNaN(parsedNumber)) return null;else {\n      return parsedNumber;\n    }\n  }\n}","import { cB, c } from \"../../../_utils/cssr/index.mjs\";\nexport default c([cB('input-number-suffix', `\n display: inline-block;\n margin-right: 10px;\n `), cB('input-number-prefix', `\n display: inline-block;\n margin-left: 10px;\n `)]);","import { h, defineComponent, ref, toRef, watch, computed, watchEffect, nextTick } from 'vue';\nimport { rgba } from 'seemly';\nimport { useMemo, useMergedState } from 'vooks';\nimport { on } from 'evtd';\nimport { RemoveIcon, AddIcon } from \"../../_internal/icons/index.mjs\";\nimport { NInput } from \"../../input/index.mjs\";\nimport { NBaseIcon } from \"../../_internal/index.mjs\";\nimport { NxButton } from \"../../button/index.mjs\";\nimport { useTheme, useFormItem, useLocale, useConfig } from \"../../_mixins/index.mjs\";\nimport { warnOnce, call, resolveSlot, resolveWrappedSlot } from \"../../_utils/index.mjs\";\nimport { inputNumberLight } from \"../styles/index.mjs\";\nimport { parse, validator, format, parseNumber, isWipValue } from \"./utils.mjs\";\nimport style from \"./styles/input-number.cssr.mjs\";\nimport { useRtl } from \"../../_mixins/use-rtl.mjs\";\nconst HOLDING_CHANGE_THRESHOLD = 800;\nconst HOLDING_CHANGE_INTERVAL = 100;\nexport const inputNumberProps = Object.assign(Object.assign({}, useTheme.props), {\n  autofocus: Boolean,\n  loading: {\n    type: Boolean,\n    default: undefined\n  },\n  placeholder: String,\n  defaultValue: {\n    type: Number,\n    default: null\n  },\n  value: Number,\n  step: {\n    type: [Number, String],\n    default: 1\n  },\n  min: [Number, String],\n  max: [Number, String],\n  size: String,\n  disabled: {\n    type: Boolean,\n    default: undefined\n  },\n  validator: Function,\n  bordered: {\n    type: Boolean,\n    default: undefined\n  },\n  showButton: {\n    type: Boolean,\n    default: true\n  },\n  buttonPlacement: {\n    type: String,\n    default: 'right'\n  },\n  inputProps: Object,\n  readonly: Boolean,\n  clearable: Boolean,\n  keyboard: {\n    type: Object,\n    default: {}\n  },\n  updateValueOnInput: {\n    type: Boolean,\n    default: true\n  },\n  parse: Function,\n  format: Function,\n  precision: Number,\n  status: String,\n  'onUpdate:value': [Function, Array],\n  onUpdateValue: [Function, Array],\n  onFocus: [Function, Array],\n  onBlur: [Function, Array],\n  onClear: [Function, Array],\n  // deprecated\n  onChange: [Function, Array]\n});\nexport default defineComponent({\n  name: 'InputNumber',\n  props: inputNumberProps,\n  setup(props) {\n    if (process.env.NODE_ENV !== 'production') {\n      watchEffect(() => {\n        if (props.onChange !== undefined) {\n          warnOnce('input-number', '`on-change` is deprecated, please use `on-update:value` instead');\n        }\n      });\n    }\n    const {\n      mergedBorderedRef,\n      mergedClsPrefixRef,\n      mergedRtlRef\n    } = useConfig(props);\n    const themeRef = useTheme('InputNumber', '-input-number', style, inputNumberLight, props, mergedClsPrefixRef);\n    const {\n      localeRef\n    } = useLocale('InputNumber');\n    const formItem = useFormItem(props);\n    const {\n      mergedSizeRef,\n      mergedDisabledRef,\n      mergedStatusRef\n    } = formItem;\n    // dom ref\n    const inputInstRef = ref(null);\n    const minusButtonInstRef = ref(null);\n    const addButtonInstRef = ref(null);\n    // value\n    const uncontrolledValueRef = ref(props.defaultValue);\n    const controlledValueRef = toRef(props, 'value');\n    const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);\n    const displayedValueRef = ref('');\n    const getPrecision = value => {\n      const fraction = String(value).split('.')[1];\n      return fraction ? fraction.length : 0;\n    };\n    const getMaxPrecision = currentValue => {\n      const precisions = [props.min, props.max, props.step, currentValue].map(value => {\n        if (value === undefined) return 0;\n        return getPrecision(value);\n      });\n      return Math.max(...precisions);\n    };\n    const mergedPlaceholderRef = useMemo(() => {\n      const {\n        placeholder\n      } = props;\n      if (placeholder !== undefined) return placeholder;\n      return localeRef.value.placeholder;\n    });\n    const mergedStepRef = useMemo(() => {\n      const parsedNumber = parseNumber(props.step);\n      if (parsedNumber !== null) {\n        return parsedNumber === 0 ? 1 : Math.abs(parsedNumber);\n      }\n      return 1;\n    });\n    const mergedMinRef = useMemo(() => {\n      const parsedNumber = parseNumber(props.min);\n      if (parsedNumber !== null) return parsedNumber;else return null;\n    });\n    const mergedMaxRef = useMemo(() => {\n      const parsedNumber = parseNumber(props.max);\n      if (parsedNumber !== null) return parsedNumber;else return null;\n    });\n    const doUpdateValue = value => {\n      const {\n        value: mergedValue\n      } = mergedValueRef;\n      if (value === mergedValue) {\n        deriveDisplayedValueFromValue();\n        return;\n      }\n      const {\n        'onUpdate:value': _onUpdateValue,\n        onUpdateValue,\n        onChange\n      } = props;\n      const {\n        nTriggerFormInput,\n        nTriggerFormChange\n      } = formItem;\n      if (onChange) call(onChange, value);\n      if (onUpdateValue) call(onUpdateValue, value);\n      if (_onUpdateValue) call(_onUpdateValue, value);\n      uncontrolledValueRef.value = value;\n      nTriggerFormInput();\n      nTriggerFormChange();\n    };\n    const deriveValueFromDisplayedValue = ({\n      offset,\n      doUpdateIfValid,\n      fixPrecision,\n      isInputing\n    }) => {\n      const {\n        value: displayedValue\n      } = displayedValueRef;\n      if (isInputing && isWipValue(displayedValue)) {\n        return false;\n      }\n      const parsedValue = (props.parse || parse)(displayedValue);\n      if (parsedValue === null) {\n        if (doUpdateIfValid) doUpdateValue(null);\n        return null;\n      }\n      if (validator(parsedValue)) {\n        const currentPrecision = getPrecision(parsedValue);\n        const {\n          precision\n        } = props;\n        if (precision !== undefined && precision < currentPrecision && !fixPrecision) {\n          return false;\n        }\n        let nextValue = parseFloat((parsedValue + offset).toFixed(precision !== null && precision !== void 0 ? precision : getMaxPrecision(parsedValue)));\n        if (validator(nextValue)) {\n          const {\n            value: mergedMax\n          } = mergedMaxRef;\n          const {\n            value: mergedMin\n          } = mergedMinRef;\n          if (mergedMax !== null && nextValue > mergedMax) {\n            if (!doUpdateIfValid || isInputing) return false;\n            // if doUpdateIfValid=true, we try to make it a valid value\n            nextValue = mergedMax;\n          }\n          if (mergedMin !== null && nextValue < mergedMin) {\n            if (!doUpdateIfValid || isInputing) return false;\n            // if doUpdateIfValid=true, we try to make it a valid value\n            nextValue = mergedMin;\n          }\n          if (props.validator && !props.validator(nextValue)) return false;\n          if (doUpdateIfValid) doUpdateValue(nextValue);\n          return nextValue;\n        }\n      }\n      return false;\n    };\n    const deriveDisplayedValueFromValue = () => {\n      const {\n        value: mergedValue\n      } = mergedValueRef;\n      if (validator(mergedValue)) {\n        const {\n          format: formatProp,\n          precision\n        } = props;\n        if (formatProp) {\n          displayedValueRef.value = formatProp(mergedValue);\n        } else {\n          if (mergedValue === null || precision === undefined ||\n          // precision overflow\n          getPrecision(mergedValue) > precision) {\n            displayedValueRef.value = format(mergedValue, undefined);\n          } else {\n            displayedValueRef.value = format(mergedValue, precision);\n          }\n        }\n      } else {\n        // null can pass the validator check\n        // so mergedValue is a number\n        displayedValueRef.value = String(mergedValue);\n      }\n    };\n    deriveDisplayedValueFromValue();\n    const displayedValueInvalidRef = useMemo(() => {\n      const derivedValue = deriveValueFromDisplayedValue({\n        offset: 0,\n        doUpdateIfValid: false,\n        isInputing: false,\n        fixPrecision: false\n      });\n      return derivedValue === false;\n    });\n    const minusableRef = useMemo(() => {\n      const {\n        value: mergedValue\n      } = mergedValueRef;\n      if (props.validator && mergedValue === null) {\n        return false;\n      }\n      const {\n        value: mergedStep\n      } = mergedStepRef;\n      const derivedNextValue = deriveValueFromDisplayedValue({\n        offset: -mergedStep,\n        doUpdateIfValid: false,\n        isInputing: false,\n        fixPrecision: false\n      });\n      return derivedNextValue !== false;\n    });\n    const addableRef = useMemo(() => {\n      const {\n        value: mergedValue\n      } = mergedValueRef;\n      if (props.validator && mergedValue === null) {\n        return false;\n      }\n      const {\n        value: mergedStep\n      } = mergedStepRef;\n      const derivedNextValue = deriveValueFromDisplayedValue({\n        offset: +mergedStep,\n        doUpdateIfValid: false,\n        isInputing: false,\n        fixPrecision: false\n      });\n      return derivedNextValue !== false;\n    });\n    function doFocus(e) {\n      const {\n        onFocus\n      } = props;\n      const {\n        nTriggerFormFocus\n      } = formItem;\n      if (onFocus) call(onFocus, e);\n      nTriggerFormFocus();\n    }\n    function doBlur(e) {\n      var _a, _b;\n      if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {\n        // hit input wrapper\n        // which means not activated\n        return;\n      }\n      const value = deriveValueFromDisplayedValue({\n        offset: 0,\n        doUpdateIfValid: true,\n        isInputing: false,\n        fixPrecision: true\n      });\n      // If valid, update event has been emitted\n      // make sure e.target.value is correct in blur callback\n      if (value !== false) {\n        const inputElRef = (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.inputElRef;\n        if (inputElRef) {\n          inputElRef.value = String(value || '');\n        }\n        // If value is not changed, the displayed value may be greater than or\n        // less than the current value. The derived value is reformatted so the\n        // value is not changed. We can simply derive a new displayed value\n        if (mergedValueRef.value === value) {\n          deriveDisplayedValueFromValue();\n        }\n      } else {\n        // If not valid, nothing will be emitted, so derive displayed value from\n        // origin value\n        deriveDisplayedValueFromValue();\n      }\n      const {\n        onBlur\n      } = props;\n      const {\n        nTriggerFormBlur\n      } = formItem;\n      if (onBlur) call(onBlur, e);\n      nTriggerFormBlur();\n      // User may change value in blur callback, we make sure it will be\n      // displayed. Sometimes mergedValue won't be viewed as changed\n      void nextTick(() => {\n        deriveDisplayedValueFromValue();\n      });\n    }\n    function doClear(e) {\n      const {\n        onClear\n      } = props;\n      if (onClear) call(onClear, e);\n    }\n    function doAdd() {\n      const {\n        value: addable\n      } = addableRef;\n      if (!addable) {\n        clearAddHoldTimeout();\n        return;\n      }\n      const {\n        value: mergedValue\n      } = mergedValueRef;\n      if (mergedValue === null) {\n        if (!props.validator) {\n          doUpdateValue(createValidValue());\n        }\n      } else {\n        const {\n          value: mergedStep\n        } = mergedStepRef;\n        deriveValueFromDisplayedValue({\n          offset: mergedStep,\n          doUpdateIfValid: true,\n          isInputing: false,\n          fixPrecision: true\n        });\n      }\n    }\n    function doMinus() {\n      const {\n        value: minusable\n      } = minusableRef;\n      if (!minusable) {\n        clearMinusHoldTimeout();\n        return;\n      }\n      const {\n        value: mergedValue\n      } = mergedValueRef;\n      if (mergedValue === null) {\n        if (!props.validator) {\n          doUpdateValue(createValidValue());\n        }\n      } else {\n        const {\n          value: mergedStep\n        } = mergedStepRef;\n        deriveValueFromDisplayedValue({\n          offset: -mergedStep,\n          doUpdateIfValid: true,\n          isInputing: false,\n          fixPrecision: true\n        });\n      }\n    }\n    const handleFocus = doFocus;\n    const handleBlur = doBlur;\n    function createValidValue() {\n      if (props.validator) return null;\n      const {\n        value: mergedMin\n      } = mergedMinRef;\n      const {\n        value: mergedMax\n      } = mergedMaxRef;\n      if (mergedMin !== null) {\n        return Math.max(0, mergedMin);\n      } else if (mergedMax !== null) {\n        return Math.min(0, mergedMax);\n      } else {\n        return 0;\n      }\n    }\n    function handleClear(e) {\n      doClear(e);\n      doUpdateValue(null);\n    }\n    function handleMouseDown(e) {\n      var _a, _b, _c;\n      if ((_a = addButtonInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.target)) {\n        e.preventDefault();\n      }\n      if ((_b = minusButtonInstRef.value) === null || _b === void 0 ? void 0 : _b.$el.contains(e.target)) {\n        e.preventDefault();\n      }\n      (_c = inputInstRef.value) === null || _c === void 0 ? void 0 : _c.activate();\n    }\n    let minusHoldStateIntervalId = null;\n    let addHoldStateIntervalId = null;\n    let firstMinusMousedownId = null;\n    function clearMinusHoldTimeout() {\n      if (firstMinusMousedownId) {\n        window.clearTimeout(firstMinusMousedownId);\n        firstMinusMousedownId = null;\n      }\n      if (minusHoldStateIntervalId) {\n        window.clearInterval(minusHoldStateIntervalId);\n        minusHoldStateIntervalId = null;\n      }\n    }\n    function clearAddHoldTimeout() {\n      if (firstAddMousedownId) {\n        window.clearTimeout(firstAddMousedownId);\n        firstAddMousedownId = null;\n      }\n      if (addHoldStateIntervalId) {\n        window.clearInterval(addHoldStateIntervalId);\n        addHoldStateIntervalId = null;\n      }\n    }\n    function handleMinusMousedown() {\n      clearMinusHoldTimeout();\n      firstMinusMousedownId = window.setTimeout(() => {\n        minusHoldStateIntervalId = window.setInterval(() => {\n          doMinus();\n        }, HOLDING_CHANGE_INTERVAL);\n      }, HOLDING_CHANGE_THRESHOLD);\n      on('mouseup', document, clearMinusHoldTimeout, {\n        once: true\n      });\n    }\n    let firstAddMousedownId = null;\n    function handleAddMousedown() {\n      clearAddHoldTimeout();\n      firstAddMousedownId = window.setTimeout(() => {\n        addHoldStateIntervalId = window.setInterval(() => {\n          doAdd();\n        }, HOLDING_CHANGE_INTERVAL);\n      }, HOLDING_CHANGE_THRESHOLD);\n      on('mouseup', document, clearAddHoldTimeout, {\n        once: true\n      });\n    }\n    const handleAddClick = () => {\n      if (addHoldStateIntervalId) return;\n      doAdd();\n    };\n    const handleMinusClick = () => {\n      if (minusHoldStateIntervalId) return;\n      doMinus();\n    };\n    function handleKeyDown(e) {\n      var _a, _b;\n      if (e.key === 'Enter') {\n        if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {\n          // hit input wrapper\n          // which means not activated\n          return;\n        }\n        const value = deriveValueFromDisplayedValue({\n          offset: 0,\n          doUpdateIfValid: true,\n          isInputing: false,\n          fixPrecision: true\n        });\n        if (value !== false) {\n          (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.deactivate();\n        }\n      } else if (e.key === 'ArrowUp') {\n        if (!addableRef.value) return;\n        if (props.keyboard.ArrowUp === false) return;\n        e.preventDefault();\n        const value = deriveValueFromDisplayedValue({\n          offset: 0,\n          doUpdateIfValid: true,\n          isInputing: false,\n          fixPrecision: true\n        });\n        if (value !== false) {\n          doAdd();\n        }\n      } else if (e.key === 'ArrowDown') {\n        if (!minusableRef.value) return;\n        if (props.keyboard.ArrowDown === false) return;\n        e.preventDefault();\n        const value = deriveValueFromDisplayedValue({\n          offset: 0,\n          doUpdateIfValid: true,\n          isInputing: false,\n          fixPrecision: true\n        });\n        if (value !== false) {\n          doMinus();\n        }\n      }\n    }\n    function handleUpdateDisplayedValue(value) {\n      displayedValueRef.value = value;\n      if (props.updateValueOnInput && !props.format && !props.parse && props.precision === undefined) {\n        deriveValueFromDisplayedValue({\n          offset: 0,\n          doUpdateIfValid: true,\n          isInputing: true,\n          fixPrecision: false\n        });\n      }\n    }\n    watch(mergedValueRef, () => {\n      deriveDisplayedValueFromValue();\n    });\n    const exposedMethods = {\n      focus: () => {\n        var _a;\n        return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();\n      },\n      blur: () => {\n        var _a;\n        return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();\n      },\n      select: () => {\n        var _a;\n        return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.select();\n      }\n    };\n    const rtlEnabledRef = useRtl('InputNumber', mergedRtlRef, mergedClsPrefixRef);\n    return Object.assign(Object.assign({}, exposedMethods), {\n      rtlEnabled: rtlEnabledRef,\n      inputInstRef,\n      minusButtonInstRef,\n      addButtonInstRef,\n      mergedClsPrefix: mergedClsPrefixRef,\n      mergedBordered: mergedBorderedRef,\n      uncontrolledValue: uncontrolledValueRef,\n      mergedValue: mergedValueRef,\n      mergedPlaceholder: mergedPlaceholderRef,\n      displayedValueInvalid: displayedValueInvalidRef,\n      mergedSize: mergedSizeRef,\n      mergedDisabled: mergedDisabledRef,\n      displayedValue: displayedValueRef,\n      addable: addableRef,\n      minusable: minusableRef,\n      mergedStatus: mergedStatusRef,\n      handleFocus,\n      handleBlur,\n      handleClear,\n      handleMouseDown,\n      handleAddClick,\n      handleMinusClick,\n      handleAddMousedown,\n      handleMinusMousedown,\n      handleKeyDown,\n      handleUpdateDisplayedValue,\n      // theme\n      mergedTheme: themeRef,\n      inputThemeOverrides: {\n        paddingSmall: '0 8px 0 10px',\n        paddingMedium: '0 8px 0 12px',\n        paddingLarge: '0 8px 0 14px'\n      },\n      buttonThemeOverrides: computed(() => {\n        const {\n          self: {\n            iconColorDisabled\n          }\n        } = themeRef.value;\n        const [r, g, b, a] = rgba(iconColorDisabled);\n        return {\n          textColorTextDisabled: `rgb(${r}, ${g}, ${b})`,\n          opacityDisabled: `${a}`\n        };\n      })\n    });\n  },\n  render() {\n    const {\n      mergedClsPrefix,\n      $slots\n    } = this;\n    const renderMinusButton = () => {\n      return h(NxButton, {\n        text: true,\n        disabled: !this.minusable || this.mergedDisabled || this.readonly,\n        focusable: false,\n        theme: this.mergedTheme.peers.Button,\n        themeOverrides: this.mergedTheme.peerOverrides.Button,\n        builtinThemeOverrides: this.buttonThemeOverrides,\n        onClick: this.handleMinusClick,\n        onMousedown: this.handleMinusMousedown,\n        ref: \"minusButtonInstRef\"\n      }, {\n        icon: () => resolveSlot($slots['minus-icon'], () => [h(NBaseIcon, {\n          clsPrefix: mergedClsPrefix\n        }, {\n          default: () => h(RemoveIcon, null)\n        })])\n      });\n    };\n    const renderAddButton = () => {\n      return h(NxButton, {\n        text: true,\n        disabled: !this.addable || this.mergedDisabled || this.readonly,\n        focusable: false,\n        theme: this.mergedTheme.peers.Button,\n        themeOverrides: this.mergedTheme.peerOverrides.Button,\n        builtinThemeOverrides: this.buttonThemeOverrides,\n        onClick: this.handleAddClick,\n        onMousedown: this.handleAddMousedown,\n        ref: \"addButtonInstRef\"\n      }, {\n        icon: () => resolveSlot($slots['add-icon'], () => [h(NBaseIcon, {\n          clsPrefix: mergedClsPrefix\n        }, {\n          default: () => h(AddIcon, null)\n        })])\n      });\n    };\n    return h(\"div\", {\n      class: [`${mergedClsPrefix}-input-number`, this.rtlEnabled && `${mergedClsPrefix}-input-number--rtl`]\n    }, h(NInput, {\n      ref: \"inputInstRef\",\n      autofocus: this.autofocus,\n      status: this.mergedStatus,\n      bordered: this.mergedBordered,\n      loading: this.loading,\n      value: this.displayedValue,\n      onUpdateValue: this.handleUpdateDisplayedValue,\n      theme: this.mergedTheme.peers.Input,\n      themeOverrides: this.mergedTheme.peerOverrides.Input,\n      builtinThemeOverrides: this.inputThemeOverrides,\n      size: this.mergedSize,\n      placeholder: this.mergedPlaceholder,\n      disabled: this.mergedDisabled,\n      readonly: this.readonly,\n      textDecoration: this.displayedValueInvalid ? 'line-through' : undefined,\n      onFocus: this.handleFocus,\n      onBlur: this.handleBlur,\n      onKeydown: this.handleKeyDown,\n      onMousedown: this.handleMouseDown,\n      onClear: this.handleClear,\n      clearable: this.clearable,\n      inputProps: this.inputProps,\n      internalLoadingBeforeSuffix: true\n    }, {\n      prefix: () => {\n        var _a;\n        return this.showButton && this.buttonPlacement === 'both' ? [renderMinusButton(), resolveWrappedSlot($slots.prefix, children => {\n          if (children) {\n            return h(\"span\", {\n              class: `${mergedClsPrefix}-input-number-prefix`\n            }, children);\n          }\n          return null;\n        })] : (_a = $slots.prefix) === null || _a === void 0 ? void 0 : _a.call($slots);\n      },\n      suffix: () => {\n        var _a;\n        return this.showButton ? [resolveWrappedSlot($slots.suffix, children => {\n          if (children) {\n            return h(\"span\", {\n              class: `${mergedClsPrefix}-input-number-suffix`\n            }, children);\n          }\n          return null;\n        }), this.buttonPlacement === 'right' ? renderMinusButton() : null, renderAddButton()] : (_a = $slots.suffix) === null || _a === void 0 ? void 0 : _a.call($slots);\n      }\n    }));\n  }\n});"],"names":["useInjectionInstanceCollection","injectionName","collectionKey","registerKeyRef","_a","injection","inject","vm","getCurrentInstance","proxy","registerInstance","key","oldKey","collection","splice","findIndex","instance","removeInstance","push","addInstance","watch","value","onBeforeUnmount","RemoveIcon","defineComponent","name","render","h","xmlns","viewBox","x1","y1","x2","y2","style","formInjectionKey","createInjectionKey","formItemInstsInjectionKey","cubicBezierEaseInOut","commonVariables","style$1","cB","cE","cM","c","transition","color","fromOffset","enterDuration","leaveDuration","enterCubicBezier","leaveCubicBezier","opacity","transform","fadeDownTransition","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","wrapValidator","validator","async","args","validateResult","Error","Array","isArray","warn","err","__unplugin_components_16","props","Object","assign","useTheme","label","String","labelWidth","Number","labelStyle","labelAlign","labelPlacement","path","first","Boolean","rulePath","required","showRequireMark","type","default","requireMarkPlacement","showFeedback","rule","size","ignorePathChange","validationStatus","feedback","showLabel","labelProps","setup","toRef","mergedClsPrefixRef","inlineThemeDisabled","useConfig","NForm","formItemSizeRefs","mergedSize","computed","formItemSize","formItemMiscRefs","mergedLabelPlacementRef","isAutoLabelWidthRef","mergedLabelWidthRef","formatLength","autoComputedWidth","maxChildLabelWidthRef","mergedLabelAlignRef","mergedLabelStyleRef","width","mergedShowRequireMarkRef","mergedRequireMarkPlacementRef","validationErroredRef","ref","validationWarnedRef","mergedValidationStatusRef","mergedShowFeedbackRef","mergedShowLabelRef","validationErrored","validationWarned","mergedLabelStyle","mergedLabelPlacement","mergedLabelAlign","mergedShowRequireMark","mergedRequireMarkPlacement","mergedValidationStatus","mergedShowFeedback","mergedShowLabel","isAutoLabelWidth","formItemMisc","mergedRequired","mergedRequiredRef","mergedRules","mergedRulesRef","compatibleRulePathRef","rules","formRules","formRule","get","hasRequiredRuleRef","some","formItemRule","mergedSizeRef","labelPlacementRef","labelTextAlignRef","renderExplainsRef","feedbackIdRef","createId","mergedDisabledRef","themeRef","formLight","restoreValidation","internalValidate","trigger","shouldRuleBeApplied","options","suppressWarning","this","model","messageRenderers","originalMessageRendersMessage","activeRules","filter","includes","map","i","shallowClonedRule","asyncValidator","renderMessage","rendererKey","message","activeErrorRules","r","level","activeWarningRules","mergedPath","Schema","warningValidator","validateMessages","messages","renderMessages","errors","error","transformedMessage","startsWith","forEach","validationResult","valid","warnings","length","validate","provide","formItemInjectionKey","disabled","handleContentBlur","handleContentChange","handleContentFocus","handleContentInput","exposedRef","callback","validateCallback","asyncValidatorOptions","labelElementRef","onMounted","labelElement","memoizedWhitespace","whiteSpace","deriveMaxChildLabelWidth","getComputedStyle","slice","cssVarsRef","direction","common","self","labelTextColor","asteriskColor","lineHeight","feedbackTextColor","feedbackTextColorWarning","feedbackTextColorError","feedbackPadding","labelFontWeight","createKey","labelHeight","blankHeight","feedbackFontSize","feedbackHeight","labelPadding","labelTextAlign","labelFontSize","mergedLabelTextAlign","themeClassHandle","useThemeClass","reverseColSpaceRef","mergedClsPrefix","feedbackId","renderExplains","reverseColSpace","cssVars","themeClass","onRender","$slots","renderedShowRequireMark","class","labelText","textNode","markNode","renderLabel","Transition","mode","resolveWrappedSlot","children","feedbackNodes","inputNumberLight$1","createTheme","commonLight","peers","Button","buttonLight","Input","inputLight","vars","textColorDisabled","iconColorDisabled","parse","trim","isNaN","format","precision","toFixed","parseNumber","number","parsedNumber","__unplugin_components_20","autofocus","loading","placeholder","defaultValue","min","max","Function","bordered","showButton","buttonPlacement","inputProps","readonly","clearable","keyboard","updateValueOnInput","status","onUpdateValue","onFocus","onBlur","onClear","onChange","watchEffect","warnOnce","mergedBorderedRef","mergedRtlRef","inputNumberLight","localeRef","useLocale","formItem","useFormItem","mergedStatusRef","inputInstRef","minusButtonInstRef","addButtonInstRef","uncontrolledValueRef","controlledValueRef","mergedValueRef","useMergedState","displayedValueRef","getPrecision","fraction","split","mergedPlaceholderRef","useMemo","mergedStepRef","Math","abs","mergedMinRef","mergedMaxRef","doUpdateValue","mergedValue","_onUpdateValue","nTriggerFormInput","nTriggerFormChange","call","deriveValueFromDisplayedValue","offset","doUpdateIfValid","fixPrecision","isInputing","displayedValue","test","parsedValue","currentPrecision","nextValue","parseFloat","currentValue","precisions","getMaxPrecision","mergedMax","mergedMin","deriveDisplayedValueFromValue","formatProp","displayedValueInvalidRef","minusableRef","mergedStep","addableRef","doAdd","addable","createValidValue","doMinus","minusable","handleFocus","nTriggerFormFocus","handleBlur","_b","target","wrapperElRef","inputElRef","nTriggerFormBlur","nextTick","minusHoldStateIntervalId","addHoldStateIntervalId","firstMinusMousedownId","clearMinusHoldTimeout","window","clearTimeout","clearInterval","clearAddHoldTimeout","firstAddMousedownId","exposedMethods","focus","blur","select","rtlEnabledRef","useRtl","rtlEnabled","mergedBordered","uncontrolledValue","mergedPlaceholder","displayedValueInvalid","mergedDisabled","mergedStatus","handleClear","doClear","handleMouseDown","_c","$el","contains","preventDefault","activate","handleAddClick","handleMinusClick","handleAddMousedown","setTimeout","setInterval","on","document","once","handleMinusMousedown","handleKeyDown","deactivate","ArrowUp","ArrowDown","handleUpdateDisplayedValue","mergedTheme","inputThemeOverrides","paddingSmall","paddingMedium","paddingLarge","buttonThemeOverrides","g","b","a","rgba","textColorTextDisabled","opacityDisabled","renderMinusButton","NxButton","text","focusable","theme","themeOverrides","peerOverrides","builtinThemeOverrides","onClick","onMousedown","icon","resolveSlot","NBaseIcon","clsPrefix","renderAddButton","AddIcon","NInput","textDecoration","onKeydown","internalLoadingBeforeSuffix","prefix","suffix"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}