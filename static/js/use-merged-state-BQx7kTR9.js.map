{"version":3,"file":"use-merged-state-BQx7kTR9.js","sources":["../../../node_modules/naive-ui/es/_utils/vue/call.mjs","../../../node_modules/naive-ui/es/_utils/vue/resolve-slot.mjs","../../../node_modules/vooks/es/use-merged-state.js"],"sourcesContent":["function call(funcs, ...args) {\n  if (Array.isArray(funcs)) {\n    funcs.forEach(func => call(func, ...args));\n  } else return funcs(...args);\n}\nexport { call };","import { Fragment, isVNode, Comment } from 'vue';\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some(child => {\n    if (!isVNode(child)) {\n      return true;\n    }\n    if (child.type === Comment) {\n      return false;\n    }\n    if (child.type === Fragment && !ensureValidVNode(child.children)) {\n      return false;\n    }\n    return true;\n  }) ? vnodes : null;\n}\n/**\n * We shouldn't use the following functions with slot flags `_: 1, 2, 3`\n */\nexport function resolveSlot(slot, fallback) {\n  return slot && ensureValidVNode(slot()) || fallback();\n}\nexport function resolveSlotWithProps(slot, props, fallback) {\n  return slot && ensureValidVNode(slot(props)) || fallback(props);\n}\n/**\n * Resolve slot with wrapper if content exists, no fallback\n */\nexport function resolveWrappedSlot(slot, wrapper) {\n  const children = slot && ensureValidVNode(slot());\n  return wrapper(children || null);\n}\n/*\n * Resolve slot with wrapper if content exists, no fallback\n */\nexport function resolveWrappedSlotWithProps(slot, props, wrapper) {\n  const children = slot && ensureValidVNode(slot(props));\n  return wrapper(children || null);\n}\nexport function isSlotEmpty(slot) {\n  return !(slot && ensureValidVNode(slot()));\n}","import { watch, computed } from 'vue';\nexport default function useMergedState(controlledStateRef, uncontrolledStateRef) {\n    watch(controlledStateRef, value => {\n        if (value !== undefined) {\n            uncontrolledStateRef.value = value;\n        }\n    });\n    return computed(() => {\n        if (controlledStateRef.value === undefined) {\n            return uncontrolledStateRef.value;\n        }\n        return controlledStateRef.value;\n    });\n}\n"],"names":["call","funcs","args","Array","isArray","forEach","func","ensureValidVNode","vnodes","some","child","isVNode","type","Comment","Fragment","children","resolveSlot","slot","fallback","resolveSlotWithProps","props","resolveWrappedSlot","wrapper","resolveWrappedSlotWithProps","isSlotEmpty","useMergedState","controlledStateRef","uncontrolledStateRef","watch","value","computed"],"mappings":"qEAAA,SAASA,EAAKC,KAAUC,GAClB,IAAAC,MAAMC,QAAQH,GAEJ,OAAAA,KAASC,GADrBD,EAAMI,SAAgBC,GAAAN,EAAKM,KAASJ,IAExC,CCHA,SAASK,EAAiBC,GACjB,OAAAA,EAAOC,MAAcC,IACrBC,EAAQD,IAGTA,EAAME,OAASC,KAGfH,EAAME,OAASE,IAAaP,EAAiBG,EAAMK,aAIpDP,EAAS,IAChB,CAIO,SAASQ,EAAYC,EAAMC,GAChC,OAAOD,GAAQV,EAAiBU,MAAWC,GAC7C,CACO,SAASC,EAAqBF,EAAMG,EAAOF,GAChD,OAAOD,GAAQV,EAAiBU,EAAKG,KAAWF,EAASE,EAC3D,CAIO,SAASC,EAAmBJ,EAAMK,GAEhC,OAAAA,EADUL,GAAQV,EAAiBU,MACf,KAC7B,CAIO,SAASM,EAA4BN,EAAMG,EAAOE,GAEhD,OAAAA,EADUL,GAAQV,EAAiBU,EAAKG,KACpB,KAC7B,CACO,SAASI,EAAYP,GAC1B,QAASA,GAAQV,EAAiBU,KACpC,CCvCe,SAASQ,EAAeC,EAAoBC,GAMvD,OALAC,EAAMF,GAA6BG,SACjB,IAAVA,IACAF,EAAqBE,MAAQA,EAChC,IAEEC,GAAS,SACqB,IAA7BJ,EAAmBG,MACZF,EAAqBE,MAEzBH,EAAmBG,OAElC","x_google_ignoreList":[0,1,2]}